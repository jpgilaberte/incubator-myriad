package org.apache.myriad.driver.model;

import java.io.Serializable;
import java.util.List;

public class MesosV1 {
    // Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


    /**
     * Status is used to indicate the state of the scheduler and executor
     * driver after function calls.
     */
    public enum Status {
        DRIVER_NOT_STARTED,
        DRIVER_RUNNING,
        DRIVER_ABORTED,
        DRIVER_STOPPED
    }


    /**
     * A unique ID assigned to a framework. A framework can reuse this ID
     * in order to do failover (see MesosSchedulerDriver).
     */
    public static class FrameworkID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * A unique ID assigned to an offer.
     */
    public static class OfferID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * A unique ID assigned to an agent. Currently, an agent gets a new ID
     * whenever it (re)registers with Mesos. Framework writers shouldn't
     * assume any binding between an agent ID and and a hostname.
     */
    public static class AgentID implements Serializable {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * A framework-generated ID to distinguish a task. The ID must remain
     * unique while the task is active. A framework can reuse an ID _only_
     * if the previous task with the same ID has reached a terminal state
     * (e.g., TASK_FINISHED, TASK_KILLED, etc.). However, reusing task IDs
     * is strongly discouraged (MESOS-2198).
     */
    public static class TaskID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * A framework-generated ID to distinguish an executor. Only one
     * executor with the same ID can be active on the same agent at a
     * time. However, reusing executor IDs is discouraged.
     */
    public static class ExecutorID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * ID used to uniquely identify a container. If the `parent` is not
     * specified, the ID is a UUID generated by the agent to uniquely
     * identify the container of an executor run. If the `parent` field is
     * specified, it represents a nested container.
     */
    public static class ContainerID {
        String value;
        ContainerID parent;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        public ContainerID getParent() {
            return parent;
        }

        public void setParent(ContainerID parent) {
            this.parent = parent;
        }
    }


    /**
     * A unique ID assigned to a resource provider. Currently, a resource
     * provider gets a new ID whenever it (re)registers with Mesos.
     */
    public static class ResourceProviderID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * A framework-generated ID to distinguish an operation. The ID
     * must be unique within the framework.
     */
    public static class OperationID {
        String value;

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * Represents time since the epoch, in nanoseconds.
     */
    public static class TimeInfo {
        Integer nanoseconds;

        public Integer getNanoseconds() {
            return nanoseconds;
        }

        public void setNanoseconds(Integer nanoseconds) {
            this.nanoseconds = nanoseconds;
        }
    }


    /**
     * Represents duration in nanoseconds.
     */
    public static class DurationInfo {
        Integer nanoseconds;

        public Integer getNanoseconds() {
            return nanoseconds;
        }

        public void setNanoseconds(Integer nanoseconds) {
            this.nanoseconds = nanoseconds;
        }
    }


    /**
     * A network address.
     *
     * TODO(bmahler): Use this more widely.
     */
    public static class Address {
        // May contain a hostname, IP address, or both.
        String hostname;
        String ip;

        Integer port;

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }
    }


    /**
     * Represents a URL.
     */
    public static class URL {
        String scheme;
        Address address;
        String path;
        List<Parameter> query;
        String fragment;

        public String getScheme() {
            return scheme;
        }

        public void setScheme(String scheme) {
            this.scheme = scheme;
        }

        public Address getAddress() {
            return address;
        }

        public void setAddress(Address address) {
            this.address = address;
        }

        public String getPath() {
            return path;
        }

        public void setPath(String path) {
            this.path = path;
        }

        public List<Parameter> getQuery() {
            return query;
        }

        public void setQuery(List<Parameter> query) {
            this.query = query;
        }

        public String getFragment() {
            return fragment;
        }

        public void setFragment(String fragment) {
            this.fragment = fragment;
        }
    }


    /**
     * Represents an interval, from a given start time over a given duration.
     * This interval pertains to an unavailability event, such as maintenance,
     * and is not a generic interval.
     */
    public static class Unavailability {
        TimeInfo start;

        // When added to `start`, this represents the end of the interval.
        // If unspecified, the duration is assumed to be infinite.
        DurationInfo duration;

        // TODO(josephw): Add additional fields for expressing the purpose and
        // urgency of the unavailability event.


        public TimeInfo getStart() {
            return start;
        }

        public void setStart(TimeInfo start) {
            this.start = start;
        }

        public DurationInfo getDuration() {
            return duration;
        }

        public void setDuration(DurationInfo duration) {
            this.duration = duration;
        }
    }


    /**
     * Represents a single machine, which may hold one or more agents.
     *
     * NOTE: In order to match an agent to a machine, both the `hostname` and
     * `ip` must match the values advertised by the agent to the master.
     * Hostname is not case-sensitive.
     */
    public static class MachineID {
        String hostname;
        String ip;

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }
    }


    /**
     * Holds information about a single machine, its `mode`, and any other
     * relevant information which may affect the behavior of the machine.
     */
    public static class MachineInfo {
        // Describes the several states that a machine can be in.  A `Mode`
        // applies to a machine and to all associated agents on the machine.
        public enum Mode {
            // In this mode, a machine is behaving normally;
            // offering resources, executing tasks, etc.
            UP,

            // In this mode, all agents on the machine are expected to cooperate with
            // frameworks to drain resources.  In general, draining is done ahead of
            // a pending `unavailability`.  The resources should be drained so as to
            // maximize utilization prior to the maintenance but without knowingly
            // violating the frameworks' requirements.
            DRAINING,

            // In this mode, a machine is not running any tasks and will not offer
            // any of its resources.  Agents on the machine will not be allowed to
            // register with the master.
            DOWN
        }

        MachineID id;
        Mode mode;

        // Signifies that the machine may be unavailable during the given interval.
        // See comments in `Unavailability` and for the `unavailability` fields
        // in `Offer` and `InverseOffer` for more information.
        Unavailability unavailability;

        public MachineID getId() {
            return id;
        }

        public void setId(MachineID id) {
            this.id = id;
        }

        public Mode getMode() {
            return mode;
        }

        public void setMode(Mode mode) {
            this.mode = mode;
        }

        public Unavailability getUnavailability() {
            return unavailability;
        }

        public void setUnavailability(Unavailability unavailability) {
            this.unavailability = unavailability;
        }
    }


    /**
     * Describes a framework.
     */
    public static class FrameworkInfo {
        // Used to determine the Unix user that an executor or task should be
        // launched as.
        //
        // When using the MesosSchedulerDriver, if the field is set to an
        // empty String, it will automagically set it to the current user.
        //
        // When using the HTTP Scheduler API, the user has to be set
        // explicitly.
        String user;

        // Name of the framework that shows up in the Mesos Web UI.
        String name;

        // Note that 'id' is only available after a framework has
        // registered, however, it is included here in order to facilitate
        // scheduler failover (i.e., if it is set then the
        // MesosSchedulerDriver expects the scheduler is performing
        // failover).
        FrameworkID id;

        // The amount of time (in seconds) that the master will wait for the
        // scheduler to failover before it tears down the framework by
        // killing all its tasks/executors. This should be non-zero if a
        // framework expects to reconnect after a failure and not lose its
        // tasks/executors.
        //
        // NOTE: To avoid accidental destruction of tasks, production
        // frameworks typically set this to a large value (e.g., 1 week).
        Double failover_timeout = 0.0;

        // If set, agents running tasks started by this framework will write
        // the framework pid, executor pids and status updates to disk. If
        // the agent exits (e.g., due to a crash or as part of upgrading
        // Mesos), this checkpointed data allows the restarted agent to
        // reconnect to executors that were started by the old instance of
        // the agent. Enabling checkpointing improves fault tolerance, at
        // the cost of a (usually small) increase in disk I/O.
        Boolean checkpoint = false;

        // Roles are the entities to which allocations are made.
        // The framework must have at least one role in order to
        // be offered resources. Note that `role` is deprecated
        // in favor of `roles` and only one of these fields must
        // be used. Since we cannot distinguish between empty
        // `roles` and the default unset `role`, we require that
        // frameworks set the `MULTI_ROLE` capability if
        // setting the `roles` field.
        String role = "*";
        List<String> roles;

        // Used to indicate the current host from which the scheduler is
        // registered in the Mesos Web UI. If set to an empty String Mesos
        // will automagically set it to the current hostname if one is
        // available.
        String hostname;

        // This field should match the credential's principal the framework
        // uses for authentication. This field is used for framework API
        // rate limiting and dynamic reservations. It should be set even
        // if authentication is not enabled if these features are desired.
        String principal;

        // This field allows a framework to advertise its web UI, so that
        // the Mesos web UI can link to it. It is expected to be a full URL,
        // for example http://my-scheduler.example.com:8080/.
        String webui_url;

        public static class Capability {
            public enum Type {
                // This must be the first public enum value in this list, to
                // ensure that if 'type' is not set, the default value
                // is UNKNOWN. This enables public enum values to be added
                // in a backwards-compatible way. See: MESOS-4997.
                UNKNOWN,

                // Receive offers with revocable resources. See 'Resource'
                // public static class for details.
                REVOCABLE_RESOURCES,

                // Receive the TASK_KILLING TaskState when a task is being
                // killed by an executor. The executor will examine this
                // capability to determine whether it can send TASK_KILLING.
                TASK_KILLING_STATE,

                // Indicates whether the framework is aware of GPU resources.
                // Frameworks that are aware of GPU resources are expected to
                // avoid placing non-GPU workloads on GPU agents, in order
                // to avoid occupying a GPU agent and preventing GPU workloads
                // from running! Currently, if a framework is unaware of GPU
                // resources, it will not be offered *any* of the resources on
                // an agent with GPUs. This restriction is in place because we
                // do not have a revocation mechanism that ensures GPU workloads
                // can evict GPU agent occupants if necessary.
                //
                // TODO(bmahler): As we add revocation we can relax the
                // restriction here. See MESOS-5634 for more information.
                GPU_RESOURCES,

                // Receive offers with resources that are shared.
                SHARED_RESOURCES,

                // Indicates that (1) the framework is prepared to handle the
                // following TaskStates: TASK_UNREACHABLE, TASK_DROPPED,
                // TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN, and (2)
                // the framework will assume responsibility for managing
                // partitioned tasks that reregister with the master.
                //
                // Frameworks that enable this capability can define how they
                // would like to handle partitioned tasks. Frameworks will
                // receive TASK_UNREACHABLE for tasks on agents that are
                // partitioned from the master.
                //
                // Without this capability, frameworks will receive TASK_LOST
                // for tasks on partitioned agents.
                // NOTE: Prior to Mesos 1.5, such tasks will be killed by Mesos
                // when the agent reregisters (unless the master has failed over).
                // However due to the lack of benefit in maintaining different
                // behaviors depending on whether the master has failed over
                // (see MESOS-7215), as of 1.5, Mesos will not kill these
                // tasks in either case.
                PARTITION_AWARE,

                // This expresses the ability for the framework to be
                // "multi-tenant" via using the newly introduced `roles`
                // field, and examining `Offer.allocation_info` to determine
                // which role the offers are being made to. We also
                // expect that "single-tenant" schedulers eventually
                // provide this and move away from the deprecated
                // `role` field.
                MULTI_ROLE,

                // This capability has two effects for a framework.
                //
                // (1) The framework is offered resources in a new format.
                //
                //     The offered resources have the `Resource.reservations` field set
                //     rather than `Resource.role` and `Resource.reservation`. In short,
                //     an empty `reservations` field denotes unreserved resources, and
                //     each `ReservationInfo` in the `reservations` field denotes a
                //     reservation that refines the previous one.
                //
                //     See the 'Resource Format' section for more details.
                //
                // (2) The framework can create refined reservations.
                //
                //     A framework can refine an existing reservation via the
                //     `Resource.reservations` field. For example, a reservation for role
                //     `eng` can be refined to `eng/front_end`.
                //
                //     See `ReservationInfo.reservations` for more details.
                //
                // NOTE: Without this capability, a framework is not offered resources
                // that have refined reservations. A resource is said to have refined
                // reservations if it uses the `Resource.reservations` field, and
                // `Resource.reservations_size() > 1`.
                RESERVATION_REFINEMENT, // EXPERIMENTAL.

                // Indicates that the framework is prepared to receive offers
                // for agents whose region is different from the master's
                // region. Network links between hosts in different regions
                // typically have higher latency and lower bandwidth than
                // network links within a region, so frameworks should be
                // careful to only place suitable workloads in remote regions.
                // Frameworks that are not region-aware will never receive
                // offers for remote agents; region-aware frameworks are assumed
                // to implement their own logic to decide which workloads (if
                // any) are suitable for placement on remote agents.
                REGION_AWARE
            }
            public Capability(Type type){
                this.type = type;
            }
            // public enum fields should be , see: MESOS-4997.
            Type type;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }
        }

        // This field allows a framework to advertise its set of
        // capabilities (e.g., ability to receive offers for revocable
        // resources).
        List<Capability> capabilities;

        // Labels are free-form key value pairs supplied by the framework
        // scheduler (e.g., to describe additional functionality offered by
        // the framework). These labels are not interpreted by Mesos itself.
        // Labels should not contain duplicate key-value pairs.
        Labels labels;

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public FrameworkID getId() {
            return id;
        }

        public void setId(FrameworkID id) {
            this.id = id;
        }

        public Double getFailover_timeout() {
            return failover_timeout;
        }

        public void setFailover_timeout(Double failover_timeout) {
            this.failover_timeout = failover_timeout;
        }

        public Boolean getCheckpoint() {
            return checkpoint;
        }

        public void setCheckpoint(Boolean checkpoint) {
            this.checkpoint = checkpoint;
        }

        public String getRole() {
            return role;
        }

        public void setRole(String role) {
            this.role = role;
        }

        public List<String> getRoles() {
            return roles;
        }

        public void setRoles(List<String> roles) {
            this.roles = roles;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public String getPrincipal() {
            return principal;
        }

        public void setPrincipal(String principal) {
            this.principal = principal;
        }

        public String getWebui_url() {
            return webui_url;
        }

        public void setWebui_url(String webui_url) {
            this.webui_url = webui_url;
        }

        public List<Capability> getCapabilities() {
            return capabilities;
        }

        public void setCapabilities(List<Capability> capabilities) {
            this.capabilities = capabilities;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }
    }


    /**
     * Describes a general non-interpreting non-killing check for a task or
     * executor (or any arbitrary process/command). A type is picked by
     * specifying one of the  fields. Specifying more than one type
     * is an error.
     *
     * NOTE: This API is unstable and the related feature is experimental.
     */
    public static class CheckInfo {
        public enum Type {
            UNKNOWN,
            COMMAND,
            HTTP,
            TCP

            // TODO(alexr): Consider supporting custom user checks. They should
            // probably be paired with a `data` field and complemented by a
            // `data` response in `CheckStatusInfo`.
        }

        // Describes a command check. If applicable, enters mount and/or network
        // namespaces of the task.
        public static class Command {
            CommandInfo command;
        }

        // Describes an HTTP check. Sends a GET request to
        // http://<host>:port/path. Note that <host> is not configurable and is
        // resolved automatically to 127.0.0.1.
        public static class Http {
            // Port to send the HTTP request.
            Integer port;

            // HTTP request path.
            String path;

            // TODO(alexr): Add support for HTTP method. While adding POST
            // and PUT is simple, supporting payload is more involved.

            // TODO(alexr): Add support for custom HTTP headers.

            // TODO(alexr): Consider adding an  public static class to describe TLS
            // options and thus enabling https. Such public static class might contain certificate
            // validation, TLS version.
        }

        // Describes a TCP check, i.e. based on establishing a TCP connection to
        // the specified port. Note that <host> is not configurable and is resolved
        // automatically to 127.0.0.1.
        public static class Tcp {
            Integer port;
        }

        // The type of the check.
        Type type;

        // Command check.
        Command command;

        // HTTP check.
        Http http;

        // TCP check.
        Tcp tcp;

        // Amount of time to wait to start checking the task after it
        // transitions to `TASK_RUNNING` or `TASK_STARTING` if the latter
        // is used by the executor.
        Double delay_seconds =5.0;

        // Interval between check attempts, i.e., amount of time to wait after
        // the previous check finished or timed out to start the next check.
        Double interval_seconds = 0.0;

        // Amount of time to wait for the check to complete. Zero means infinite
        // timeout.
        //
        // After this timeout, the check attempt is aborted and no result is
        // reported. Note that this may be considered a state change and hence
        // may trigger a check status change delivery to the corresponding
        // scheduler. See `CheckStatusInfo` for more details.
        Double timeout_seconds = 0.0;
    }


    /**
     * Describes a health check for a task or executor (or any arbitrary
     * process/command). A type is picked by specifying one of the
     *  fields. Specifying more than one type is an error.
     */
    public static class HealthCheck {
        public enum Type {
            UNKNOWN,
            COMMAND,
            HTTP,
            TCP
        }

        // Describes an HTTP health check. Sends a GET request to
        // scheme://<host>:port/path. Note that <host> is not configurable and is
        // resolved automatically, in most cases to 127.0.0.1. Default executors
        // treat return codes between 200 and 399 as success; custom executors
        // may employ a different strategy, e.g. leveraging the `statuses` field.
        public static class HTTPCheckInfo {
            NetworkInfo.Protocol protocol  = NetworkInfo.Protocol.IPv4;

            // Currently "http" and "https" are supported.
            String scheme;

            // Port to send the HTTP request.
            Integer port;

            // HTTP request path.
            String path;

            // TODO(alexr): Add support for HTTP method. While adding POST
            // and PUT is simple, supporting payload is more involved.

            // TODO(alexr): Add support for custom HTTP headers.

            // TODO(alexr): Add support for success and possibly failure
            // statuses.

            // NOTE: It is up to the custom executor to interpret and act on this
            // field. Setting this field has no effect on the default executors.
            //
            // TODO(haosdent): Deprecate this field when we add better support for
            // success and possibly failure statuses, e.g. ranges of success and
            // failure statuses.
            List<Integer> statuses;

            // TODO(haosdent): Consider adding a flag to enable task's certificate
            // validation for HTTPS health checks, see MESOS-5997.

            // TODO(benh): Include an ' byte[] data' field for checking
            // for specific data in the response.
        }

        // Describes a TCP health check, i.e. based on establishing
        // a TCP connection to the specified port.
        public static class TCPCheckInfo {
            NetworkInfo.Protocol protocol = NetworkInfo.Protocol.IPv4;

            // Port expected to be open.
            Integer port;
        }

        // TODO(benh): Consider adding a URL health check strategy which
        // allows doing something similar to the HTTP strategy but
        // encapsulates all the details in a single String field.

        // Amount of time to wait to start health checking the task after it
        // transitions to `TASK_RUNNING` or `TASK_STATING` if the latter is
        // used by the executor.
        Double delay_seconds = 5.0;

        // Interval between health checks, i.e., amount of time to wait after
        // the previous health check finished or timed out to start the next
        // health check.
        Double interval_seconds = 0.0;

        // Amount of time to wait for the health check to complete. After this
        // timeout, the health check is aborted and treated as a failure. Zero
        // means infinite timeout.
        Double timeout_seconds = 0.0;

        // Number of consecutive failures until the task is killed by the executor.
        Integer consecutive_failures ;

        // Amount of time after the task is launched during which health check
        // failures are ignored. Once a check succeeds for the first time,
        // the grace period does not apply anymore. Note that it includes
        // `delay_seconds`, i.e., setting `grace_period_seconds` < `delay_seconds`
        // has no effect.
        Double grace_period_seconds = 0.0;

        // TODO(alexr): Add an  `KillPolicy` that should be used
        // if the task is killed because of a health check failure.

        // The type of health check.
        Type type;

        // Command health check.
        CommandInfo command;

        // HTTP health check.
        HTTPCheckInfo http;

        // TCP health check.
        TCPCheckInfo tcp;
    }


    /**
     * Describes a kill policy for a task. Currently does not express
     * different policies (e.g. hitting HTTP endpoints), only controls
     * how long to wait between graceful and forcible task kill:
     *
     *     graceful kill --------------> forcible kill
     *                    grace_period
     *
     * Kill policies are best-effort, because machine failures / forcible
     * terminations may occur.
     *
     * NOTE: For executor-less command-based tasks, the kill is performed
     * via sending a signal to the task process: SIGTERM for the graceful
     * kill and SIGKILL for the forcible kill. For the docker executor-less
     * tasks the grace period is passed to 'docker stop --time'.
     */
    public static class KillPolicy {
        // The grace period specifies how long to wait before forcibly
        // killing the task. It is recommended to attempt to gracefully
        // kill the task (and send TASK_KILLING) to indicate that the
        // graceful kill is in progress. Once the grace period elapses,
        // if the task has not terminated, a forcible kill should occur.
        // The task should not assume that it will always be allotted
        // the full grace period. For example, the executor may be
        // shutdown more quickly by the agent, or failures / forcible
        // terminations may occur.
        DurationInfo grace_period;
    }


    /**
     * Describes a command, executed via: '/bin/sh -c value'. Any URIs specified
     * are fetched before executing the command.  If the executable field for an
     * uri is set, executable file permission is set on the downloaded file.
     * Otherwise, if the downloaded file has a recognized archive extension
     * (currently [compressed] tar and zip) it is extracted into the executor's
     * working directory. This extraction can be disabled by setting `extract` to
     * false. In addition, any environment variables are set before executing
     * the command (so they can be used to "parameterize" your command).
     */
    public static class CommandInfo {
        public static class URI {
            String value;
            Boolean executable;

            // In case the fetched file is recognized as an archive, extract
            // its contents into the sandbox. Note that a cached archive is
            // not copied from the cache to the sandbox in case extraction
            // originates from an archive in the cache.
            Boolean extract = true;

            // If this field is "true", the fetcher cache will be used. If not,
            // fetching bypasses the cache and downloads directly into the
            // sandbox directory, no matter whether a suitable cache file is
            // available or not. The former directs the fetcher to download to
            // the file cache, then copy from there to the sandbox. Subsequent
            // fetch attempts with the same URI will omit downloading and copy
            // from the cache as long as the file is resident there. Cache files
            // may get evicted at any time, which then leads to renewed
            // downloading. See also "docs/fetcher.md" and
            // "docs/fetcher-cache-internals.md".
            Boolean cache;

            // The fetcher's default behavior is to use the URI String's basename to
            // name the local copy. If this field is provided, the local copy will be
            // named with its value instead. If there is a directory component (which
            // must be a relative path), the local copy will be stored in that
            // subdirectory inside the sandbox.
            String output_file;

            public String getValue() {
                return value;
            }

            public void setValue(String value) {
                this.value = value;
            }

            public Boolean getExecutable() {
                return executable;
            }

            public void setExecutable(Boolean executable) {
                this.executable = executable;
            }

            public Boolean getExtract() {
                return extract;
            }

            public void setExtract(Boolean extract) {
                this.extract = extract;
            }

            public Boolean getCache() {
                return cache;
            }

            public void setCache(Boolean cache) {
                this.cache = cache;
            }

            public String getOutput_file() {
                return output_file;
            }

            public void setOutput_file(String output_file) {
                this.output_file = output_file;
            }
        }

        List<URI> uris;

        Environment environment;

        // There are two ways to specify the command:
        // 1) If 'shell == true', the command will be launched via shell
        //		(i.e., /bin/sh -c 'value'). The 'value' specified will be
        //		treated as the shell command. The 'arguments' will be ignored.
        // 2) If 'shell == false', the command will be launched by passing
        //		arguments to an executable. The 'value' specified will be
        //		treated as the filename of the executable. The 'arguments'
        //		will be treated as the arguments to the executable. This is
        //		similar to how POSIX exec families launch processes (i.e.,
        //		execlp(value, arguments(0), arguments(1), ...)).
        // NOTE: The field 'value' is changed from 'required' to ''
        // in 0.20.0. It will only cause issues if a new framework is
        // connecting to an old master.
        Boolean shell = true;
        String value;
        List<String> arguments;

        // Enables executor and tasks to run as a specific user. If the user
        // field is present both in FrameworkInfo and here, the CommandInfo
        // user value takes precedence.
        String user;

        public List<URI> getUris() {
            return uris;
        }

        public void setUris(List<URI> uris) {
            this.uris = uris;
        }

        public Environment getEnvironment() {
            return environment;
        }

        public void setEnvironment(Environment environment) {
            this.environment = environment;
        }

        public Boolean getShell() {
            return shell;
        }

        public void setShell(Boolean shell) {
            this.shell = shell;
        }

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }

        public List<String> getArguments() {
            return arguments;
        }

        public void setArguments(List<String> arguments) {
            this.arguments = arguments;
        }

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }
    }


    /**
     * Describes information about an executor.
     */
    public static class ExecutorInfo implements Serializable{
        public enum Type {
            UNKNOWN,

            // Mesos provides a simple built-in default executor that frameworks can
            // leverage to run shell commands and containers.
            //
            // NOTES:
            //
            // 1) `command` must not be set when using a default executor.
            //
            // 2) Default executor only accepts a *single* `LAUNCH` or `LAUNCH_GROUP`
            //    operation.
            //
            // 3) If `container` is set, `container.type` must be `MESOS`
            //    and `container.mesos.image` must not be set.
            DEFAULT,

            // For frameworks that need custom functionality to run tasks, a `CUSTOM`
            // executor can be used. Note that `command` must be set when using a
            // `CUSTOM` executor.
            CUSTOM
        }

        // For backwards compatibility, if this field is not set when using `LAUNCH`
        // operation, Mesos will infer the type by checking if `command` is set
        // (`CUSTOM`) or unset (`DEFAULT`). `type` must be set when using
        // `LAUNCH_GROUP` operation.
        //
        // TODO(vinod): Add support for explicitly setting `type` to `DEFAULT` in
        // `LAUNCH` operation.
        Type type;

        ExecutorID executor_id;
        FrameworkID framework_id; // TODO(benh): Make this required.
        CommandInfo command;

        // Executor provided with a container will launch the container
        // with the executor's CommandInfo and we expect the container to
        // act as a Mesos executor.
        ContainerInfo container;

        List<Resource> resources;
        String name;

        // 'source' is an identifier style String used by frameworks to
        // track the source of an executor. This is useful when it's
        // possible for different executor ids to be related semantically.
        //
        // NOTE: 'source' is exposed alongside the resource usage of the
        // executor via JSON on the agent. This allows users to import usage
        // information into a time series database for monitoring.
        //
        // This field is deprecated since 1.0. Please use labels for
        // free-form metadata instead.
        String source; // Since 1.0.

        // This field can be used to pass arbitrary byte[] to an executor.
        byte[] data;

        // Service discovery information for the executor. It is not
        // interpreted or acted upon by Mesos. It is up to a service
        // discovery system to use this information as needed and to handle
        // executors without service discovery information.
        DiscoveryInfo discovery;

        // When shutting down an executor the agent will wait in a
        // best-effort manner for the grace period specified here
        // before forcibly destroying the container. The executor
        // must not assume that it will always be allotted the full
        // grace period, as the agent may decide to allot a shorter
        // period and failures / forcible terminations may occur.
        DurationInfo shutdown_grace_period;

        // Labels are free-form key value pairs which are exposed through
        // master and agent endpoints. Labels will not be interpreted or
        // acted upon by Mesos itself. As opposed to the data field, labels
        // will be kept in memory on master and agent processes. Therefore,
        // labels should be used to tag executors with lightweight metadata.
        // Labels should not contain duplicate key-value pairs.
        Labels labels;

        public Type getType() {
            return type;
        }

        public void setType(Type type) {
            this.type = type;
        }

        public ExecutorID getExecutor_id() {
            return executor_id;
        }

        public void setExecutor_id(ExecutorID executor_id) {
            this.executor_id = executor_id;
        }

        public FrameworkID getFramework_id() {
            return framework_id;
        }

        public void setFramework_id(FrameworkID framework_id) {
            this.framework_id = framework_id;
        }

        public CommandInfo getCommand() {
            return command;
        }

        public void setCommand(CommandInfo command) {
            this.command = command;
        }

        public ContainerInfo getContainer() {
            return container;
        }

        public void setContainer(ContainerInfo container) {
            this.container = container;
        }

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getSource() {
            return source;
        }

        public void setSource(String source) {
            this.source = source;
        }

        public byte[] getData() {
            return data;
        }

        public void setData(byte[] data) {
            this.data = data;
        }

        public DiscoveryInfo getDiscovery() {
            return discovery;
        }

        public void setDiscovery(DiscoveryInfo discovery) {
            this.discovery = discovery;
        }

        public DurationInfo getShutdown_grace_period() {
            return shutdown_grace_period;
        }

        public void setShutdown_grace_period(DurationInfo shutdown_grace_period) {
            this.shutdown_grace_period = shutdown_grace_period;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }
    }


    /**
     * Describes a domain. A domain is a collection of hosts that have
     * similar characteristics. Mesos currently only supports "fault
     * domains", which identify groups of hosts with similar failure
     * characteristics.
     *
     * Frameworks can generally assume that network links between hosts in
     * the same fault domain have lower latency, higher bandwidth, and better
     * availability than network links between hosts in different domains.
     * Schedulers may prefer to place network-intensive workloads in the
     * same domain, as this may improve performance. Conversely, a single
     * failure that affects a host in a domain may be more likely to
     * affect other hosts in the same domain; hence, schedulers may prefer
     * to place workloads that require high availability in multiple
     * domains. (For example, all the hosts in a single rack might lose
     * power or network connectivity simultaneously.)
     *
     * There are two kinds of fault domains: regions and zones. Regions
     * offer the highest degree of fault isolation, but network latency
     * between regions is typically high (typically >50 ms). Zones offer a
     * modest degree of fault isolation along with reasonably low network
     * latency (typically <10 ms).
     *
     * The mapping from fault domains to physical infrastructure is up to
     * the operator to configure. In cloud environments, regions and zones
     * can be mapped to the "region" and "availability zone" concepts
     * exposed by most cloud providers, respectively. In on-premise
     * deployments, regions and zones can be mapped to data centers and
     * racks, respectively.
     *
     * Both masters and agents can be configured with domains. Frameworks
     * can compare the domains of two hosts to determine if the hosts are
     * in the same zone, in different zones in the same region, or in
     * different regions. Note that all masters in a given Mesos cluster
     * must be in the same region.
     */
    public static class DomainInfo {
        public static class FaultDomain {
            public static class RegionInfo {
                String name;

                public String getName() {
                    return name;
                }

                public void setName(String name) {
                    this.name = name;
                }
            }

            public static class ZoneInfo {
                String name;

                public String getName() {
                    return name;
                }

                public void setName(String name) {
                    this.name = name;
                }
            }

            RegionInfo region;
            ZoneInfo zone;

            public RegionInfo getRegion() {
                return region;
            }

            public void setRegion(RegionInfo region) {
                this.region = region;
            }

            public ZoneInfo getZone() {
                return zone;
            }

            public void setZone(ZoneInfo zone) {
                this.zone = zone;
            }
        }

        FaultDomain fault_domain;

        public FaultDomain getFault_domain() {
            return fault_domain;
        }

        public void setFault_domain(FaultDomain fault_domain) {
            this.fault_domain = fault_domain;
        }
    }


    /**
     * Describes a master. This will probably have more fields in the
     * future which might be used, for example, to link a framework webui
     * to a master webui.
     */
    public static class MasterInfo {
        String id;

        // The IP address (only IPv4) as a packed 4-byte[] integer,
        // stored in network order.  Deprecated, use `address.ip` instead.
        Long ip;

        // The TCP port the Master is listening on for incoming
        // HTTP requests; deprecated, use `address.port` instead.
        Integer port = 5050;

        // In the default implementation, this will contain information
        // about both the IP address, port and Master name; it should really
        // not be relied upon by external tooling/frameworks and be
        // considered an "internal" implementation field.
        String pid;

        // The server's hostname, if available; it may be unreliable
        // in environments where the DNS configuration does not resolve
        // internal hostnames (eg, some public cloud providers).
        // Deprecated, use `address.hostname` instead.
        String hostname;

        // The running Master version, as a String; taken from the
        // generated "master/version.hpp".
        String version;

        // The full IP address (supports both IPv4 and IPv6 formats)
        // and supersedes the use of `ip`, `port` and `hostname`.
        // Since Mesos 0.24.
        Address address;

        // The domain that this master belongs to. All masters in a Mesos
        // cluster should belong to the same region.
        DomainInfo domain;

        public static class Capability {
            public enum Type {
                UNKNOWN,

                // The master can handle slaves whose state
                // changes after re-registering.
                AGENT_UPDATE,
            }
            Type type;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }
        }

        List<Capability> capabilities;

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public Long getIp() {
            return ip;
        }

        public void setIp(Long ip) {
            this.ip = ip;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }

        public String getPid() {
            return pid;
        }

        public void setPid(String pid) {
            this.pid = pid;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public String getVersion() {
            return version;
        }

        public void setVersion(String version) {
            this.version = version;
        }

        public Address getAddress() {
            return address;
        }

        public void setAddress(Address address) {
            this.address = address;
        }

        public DomainInfo getDomain() {
            return domain;
        }

        public void setDomain(DomainInfo domain) {
            this.domain = domain;
        }

        public List<Capability> getCapabilities() {
            return capabilities;
        }

        public void setCapabilities(List<Capability> capabilities) {
            this.capabilities = capabilities;
        }
    }


    /**
     * Describes an agent. Note that the 'id' field is only available
     * after an agent is registered with the master, and is made available
     * here to facilitate re-registration.
     */
    public static class AgentInfo {
        String hostname;
        Integer port = 5051;

        // The configured resources at the agent. This does not include any
        // dynamic reservations or persistent volumes that may currently
        // exist at the agent.
        List<Resource> resources;

        List<Attribute> attributes;
        AgentID id;

        // The domain that this agent belongs to. If the agent's region
        // differs from the master's region, it will not appear in resource
        // offers to frameworks that have not enabled the REGION_AWARE
        // capability.
        DomainInfo domain;

        public static class Capability {
            public enum Type {
                // This must be the first public enum value in this list, to
                // ensure that if 'type' is not set, the default value
                // is UNKNOWN. This enables public enum values to be added
                // in a backwards-compatible way. See: MESOS-4997.
                UNKNOWN,

                // This expresses the ability for the agent to be able
                // to launch tasks of a 'multi-role' framework.
                MULTI_ROLE,

                // This expresses the ability for the agent to be able to launch
                // tasks, reserve resources, and create volumes using resources
                // allocated to a 'hierarchical-role'.
                // NOTE: This capability is specifically for creating
                // volumes because a hierchical role includes '/' (slashes) in them.
                // Agents with this capability know to transform the '/' (slashes)
                // into ' ' (spaces).
                HIERARCHICAL_ROLE,

                // This capability has three effects for an agent.
                //
                // (1) The format of the checkpointed resources, and
                //     the resources reported to master.
                //
                //     These resources are reported in the "pre-reservation-refinement"
                //     format if none of the resources have refined reservations. If any
                //     of the resources have refined reservations, they are reported in
                //     the "post-reservation-refinement" format. The purpose is to allow
                //     downgrading of an agent as well as communication with a pre-1.4.0
                //     master until the reservation refinement feature is actually used.
                //
                //     See the 'Resource Format' section for more details.
                //
                // (2) The format of the resources reported by the HTTP endpoints.
                //
                //     For resources reported by agent endpoints, the
                //     "pre-reservation-refinement" format is "injected" if possible.
                //     That is, resources without refined reservations will have the
                //     `Resource.role` and `Resource.reservation` set, whereas
                //     resources with refined reservations will not.
                //
                //     See the 'Resource Format' section for more details.
                //
                // (3) The ability for the agent to launch tasks, reserve resources, and
                //     create volumes using resources that have refined reservations.
                //
                //     See `ReservationInfo.reservations` section for more details.
                //
                // NOTE: Resources are said to have refined reservations if it uses the
                // `Resource.reservations` field, and `Resource.reservations_size() > 1`.
                RESERVATION_REFINEMENT,

                // This expresses the ability for the agent to handle resource
                // provider related operations. This includes the following:
                //
                // (1) The ability to report resources that are provided by some
                //     local resource providers through the resource provider API.
                //
                // (2) The ability to provide operation feedback.
                RESOURCE_PROVIDER
            }

            // public enum fields should be , see: MESOS-4997.
            Type type;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public Integer getPort() {
            return port;
        }

        public void setPort(Integer port) {
            this.port = port;
        }

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }

        public List<Attribute> getAttributes() {
            return attributes;
        }

        public void setAttributes(List<Attribute> attributes) {
            this.attributes = attributes;
        }

        public AgentID getId() {
            return id;
        }

        public void setId(AgentID id) {
            this.id = id;
        }

        public DomainInfo getDomain() {
            return domain;
        }

        public void setDomain(DomainInfo domain) {
            this.domain = domain;
        }
    }


    /**
     * Describes the container configuration to run a CSI plugin component.
     */
    public static class CSIPluginContainerInfo {
        public enum Service {
            UNKNOWN,
            CONTROLLER_SERVICE,
            NODE_SERVICE
        }

        List<Service> services;
        CommandInfo command;
        List<Resource> resources;
        ContainerInfo container;
    }


    /**
     * Describes a CSI plugin.
     */
    public static class CSIPluginInfo {
        // The type of the CSI service. This uniquely identifies a CSI
        // implementation. For instance:
        //     org.apache.mesos.csi.test
        //
        // Please follow to Java package naming convention
        // (https://en.wikipedia.org/wiki/Java_package#Package_naming_conventions)
        // to avoid conflicts on type names.
        String type;

        // The name of the CSI service. There could be mutliple instances of a
        // type of CSI service. The name field is used to distinguish these
        // instances. It should be a legal Java identifier
        // (https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)
        // to avoid conflicts on concatenation of type and name.
        String name;

        // A list of container configurations to run CSI plugin components.
        // The controller service will be served by the first configuration
        // that contains `CONTROLLER_SERVICE`, and the node service will be
        // served by the first configuration that contains `NODE_SERVICE`.
        List<CSIPluginContainerInfo> containers;
    }


    /**
     * Describes a resource provider. Note that the 'id' field is only available
     * after a resource provider is registered with the master, and is made
     * available here to facilitate re-registration.
     */
    public static class ResourceProviderInfo {
        ResourceProviderID id;
        List<Attribute> attributes;

        // The type of the resource provider. This uniquely identifies a
        // resource provider implementation. For instance:
        //     org.apache.mesos.rp.local.storage
        //
        // Please follow to Java package naming convention
        // (https://en.wikipedia.org/wiki/Java_package#Package_naming_conventions)
        // to avoid conflicts on type names.
        String type;

        // The name of the resource provider. There could be multiple
        // instances of a type of resource provider. The name field is used
        // to distinguish these instances. It should be a legal Java identifier
        // (https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)
        // to avoid conflicts on concatenation of type and name.
        String name;

        // The stack of default reservations. If this field is not empty, it
        // indicates that resources from this resource provider are reserved
        // by default, except for the resources that have been reserved or
        // unreserved through operations. The first `ReservationInfo`
        // may have type `STATIC` or `DYNAMIC`, but the rest must have
        // `DYNAMIC`. One can create a new reservation on top of an existing
        // one by pushing a new `ReservationInfo` to the back. The last
        // `ReservationInfo` in this stack is the "current" reservation. The
        // new reservation's role must be a child of the current one.
        List<Resource.ReservationInfo> default_reservations; // EXPERIMENTAL.

        // Storage resource provider related information.
        public static class Storage {
            CSIPluginInfo plugin;
        }

        Storage storage; // EXPERIMENTAL.
    }


    /**
     * Describes an Attribute or Resource "value". A value is described
     * using the standard protocol buffer "union" trick.
     */
    public static class Value {
        public enum Type {
            SCALAR,
            RANGES,
            SET,
            TEXT
        }

        public static class Scalar {
            // Scalar values are represented using floating point. To reduce
            // the chance of unpredictable floating point behavior due to
            // roundoff error, Mesos only supports three decimal digits of
            // precision for scalar resource values. That is, floating point
            // values are converted to a fixed point format that supports
            // three decimal digits of precision, and then converted back to
            // floating point on output. Any additional precision in scalar
            // resource values is discarded (via rounding).
            Double value;

            public Double getValue() {
                return value;
            }

            public void setValue(Double value) {
                this.value = value;
            }
        }

        public static class Range {
            Integer begin;
            Integer end;

            public Integer getBegin() {
                return begin;
            }

            public void setBegin(Integer begin) {
                this.begin = begin;
            }

            public Integer getEnd() {
                return end;
            }

            public void setEnd(Integer end) {
                this.end = end;
            }
        }

        public static class Ranges {
            List<Range> range;

            public List<Range> getRange() {
                return range;
            }

            public void setRange(List<Range> range) {
                this.range = range;
            }
        }

        public static class Set {
            List<String> item;

            public List<String> getItem() {
                return item;
            }

            public void setItem(List<String> item) {
                this.item = item;
            }
        }

        public static class Text {
            String value;

            public String getValue() {
                return value;
            }

            public void setValue(String value) {
                this.value = value;
            }
        }

        Type type;
        Scalar scalar;
        Ranges ranges;
        Set set;
        Text text;

        public Type getType() {
            return type;
        }

        public void setType(Type type) {
            this.type = type;
        }

        public Scalar getScalar() {
            return scalar;
        }

        public void setScalar(Scalar scalar) {
            this.scalar = scalar;
        }

        public Ranges getRanges() {
            return ranges;
        }

        public void setRanges(Ranges ranges) {
            this.ranges = ranges;
        }

        public Set getSet() {
            return set;
        }

        public void setSet(Set set) {
            this.set = set;
        }

        public Text getText() {
            return text;
        }

        public void setText(Text text) {
            this.text = text;
        }
    }


    /**
     * Describes an attribute that can be set on a machine. For now,
     * attributes and resources share the same "value" type, but this may
     * change in the future and attributes may only be String based.
     */
    public static class Attribute {
        String name;
        Value.Type type;
        Value.Scalar scalar;
        Value.Ranges ranges;
        Value.Set set;
        Value.Text text;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Value.Type getType() {
            return type;
        }

        public void setType(Value.Type type) {
            this.type = type;
        }

        public Value.Scalar getScalar() {
            return scalar;
        }

        public void setScalar(Value.Scalar scalar) {
            this.scalar = scalar;
        }

        public Value.Ranges getRanges() {
            return ranges;
        }

        public void setRanges(Value.Ranges ranges) {
            this.ranges = ranges;
        }

        public Value.Set getSet() {
            return set;
        }

        public void setSet(Value.Set set) {
            this.set = set;
        }

        public Value.Text getText() {
            return text;
        }

        public void setText(Value.Text text) {
            this.text = text;
        }
    }


    /**
     * Describes a resource from a resource provider. The `name` field is
     * a String like "cpus" or "mem" that indicates which kind of resource
     * this is; the rest of the fields describe the properties of the
     * resource. A resource can take on one of three types: scalar
     * (Double), a list of finite and discrete ranges (e.g., [1-10,
     * 20-30]), or a set of items. A resource is described using the
     * standard protocol buffer "union" trick.
     *
     * Note that "disk" and "mem" resources are scalar values expressed in
     * megabyte[]. Fractional "cpus" values are allowed (e.g., "0.5"),
     * which correspond to partial shares of a CPU.
     */
    public static class Resource {
        ResourceProviderID provider_id;

        String name;
        Value.Type type;
        Value.Scalar scalar;
        Value.Ranges ranges;
        Value.Set set;

        // The role that this resource is reserved for. If "*", this indicates
        // that the resource is unreserved. Otherwise, the resource will only
        // be offered to frameworks that belong to this role.
        //
        // NOTE: Frameworks must not set this field if `reservations` is set.
        //       See the 'Resource Format' section for more details.
        //
        // TODO(mpark): Deprecate once `reservations` is no longer experimental.
        String role  = "*";

        // This was initially introduced to support MULTI_ROLE capable
        // frameworks. Frameworks that are not MULTI_ROLE capable can
        // continue to assume that the offered resources are allocated
        // to their role.
        public static class AllocationInfo {
            // If set, this resource is allocated to a role. Note that in the
            // future, this may be unset and the scheduler may be responsible
            // for allocating to one of its roles.
            String role;

            // In the future, we may add additional fields here, e.g. priority
            // tier, type of allocation (quota / fair share).


            public String getRole() {
                return role;
            }

            public void setRole(String role) {
                this.role = role;
            }
        }

        AllocationInfo allocation_info;

        // Resource Format:
        //
        // Frameworks receive resource offers in one of two formats, depending on
        // whether the RESERVATION_REFINEMENT capability is enabled.
        //
        // __WITHOUT__ the RESERVATION_REFINEMENT capability, the framework is offered
        // resources in the "pre-reservation-refinement" format. In this format, the
        // `Resource.role` and `Resource.reservation` fields are used in conjunction
        // to describe the reservation state of a `Resource` message.
        //
        // The following is an overview of the possible reservation states:
        //
        // +------------+------------------------------------------------------------+
        // | unreserved | {                                                          |
        // |            |   role: "*",                                               |
        // |            |   reservation: <not set>,                                  |
        // |            |   reservations: <unused>                                   |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        // | static     | {                                                          |
        // |            |   role: "eng",                                             |
        // |            |   reservation: <not set>,                                  |
        // |            |   reservations: <unused>                                   |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        // | dynamic    | {                                                          |
        // |            |   role: "eng",                                             |
        // |            |   reservation: {                                           |
        // |            |     type: <unused>,                                        |
        // |            |     role: <unused>,                                        |
        // |            |     principal: <>,                                 |
        // |            |     labels: <>                                     |
        // |            |   },                                                       |
        // |            |   reservations: <unused>                                   |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        //
        // __WITH__ the RESERVATION_REFINEMENT capability, the framework is offered
        // resources in the "post-reservation-refinement" format. In this format, the
        // reservation state of a `Resource` public static class is expressed solely in
        // `Resource.reservations` field.
        //
        // The following is an overview of the possible reservation states:
        //
        // +------------+------------------------------------------------------------+
        // | unreserved | {                                                          |
        // |            |   role: <unused>,                                          |
        // |            |   reservation: <unused>,                                   |
        // |            |   reservations: []                                         |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        // | static     | {                                                          |
        // |            |   role: <unused>,                                          |
        // |            |   reservation: <unused>,                                   |
        // |            |   reservations: [                                          |
        // |            |     {                                                      |
        // |            |       type: STATIC,                                        |
        // |            |       role: "eng",                                         |
        // |            |       principal: <>,                               |
        // |            |       labels: <>                                   |
        // |            |     }                                                      |
        // |            |   ]                                                        |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        // | dynamic    | {                                                          |
        // |            |   role: <unused>,                                          |
        // |            |   reservation: <unused>,                                   |
        // |            |   reservations: [                                          |
        // |            |     {                                                      |
        // |            |       type: DYNAMIC,                                       |
        // |            |       role: "eng",                                         |
        // |            |       principal: <>,                               |
        // |            |       labels: <>                                   |
        // |            |     }                                                      |
        // |            |   ]                                                        |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        //
        // We can also __refine__ reservations with this capability like so:
        //
        // +------------+------------------------------------------------------------+
        // | refined    | {                                                          |
        // |            |   role: <unused>,                                          |
        // |            |   reservation: <unused>,                                   |
        // |            |   reservations: [                                          |
        // |            |     {                                                      |
        // |            |       type: STATIC or DYNAMIC,                             |
        // |            |       role: "eng",                                         |
        // |            |       principal: <>,                               |
        // |            |       labels: <>                                   |
        // |            |     },                                                     |
        // |            |     {                                                      |
        // |            |       type: DYNAMIC,                                       |
        // |            |       role: "eng/front_end",                               |
        // |            |       principal: <>,                               |
        // |            |       labels: <>                                   |
        // |            |     }                                                      |
        // |            |   ]                                                        |
        // |            | }                                                          |
        // +------------+------------------------------------------------------------+
        //
        // NOTE: Each `ReservationInfo` in the `reservations` field denotes
        //       a reservation that refines the previous `ReservationInfo`.

        public static class ReservationInfo {
            // Describes a reservation. A static reservation is set by the operator on
            // the command-line and they are immutable without agent restart. A dynamic
            // reservation is made by an operator via the '/reserve' HTTP endpoint
            // or by a framework via the offer cycle by sending back an
            // 'Offer::Operation::Reserve' message.
            //
            // NOTE: We currently do not allow frameworks with role "*" to make dynamic
            // reservations.

            public enum Type {
                UNKNOWN,
                STATIC,
                DYNAMIC
            }

            // The type of this reservation.
            //
            // NOTE: This field must not be set for `Resource.reservation`.
            //       See the 'Resource Format' section for more details.
            Type type;

            // The role to which this reservation is made for.
            //
            // NOTE: This field must not be set for `Resource.reservation`.
            //       See the 'Resource Format' section for more details.
            String role;

            // Indicates the principal, if any, of the framework or operator
            // that reserved this resource. If reserved by a framework, the
            // field should match the `FrameworkInfo.principal`. It is used in
            // conjunction with the `UnreserveResources` ACL to determine
            // whether the entity attempting to unreserve this resource is
            // permitted to do so.
            String principal;

            // Labels are free-form key value pairs that can be used to
            // associate arbitrary metadata with a reserved resource.  For
            // example, frameworks can use labels to identify the intended
            // purpose for a portion of the resources the framework has
            // reserved at a given agent. Labels should not contain duplicate
            // key-value pairs.
            Labels labels;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }

            public String getRole() {
                return role;
            }

            public void setRole(String role) {
                this.role = role;
            }

            public String getPrincipal() {
                return principal;
            }

            public void setPrincipal(String principal) {
                this.principal = principal;
            }

            public Labels getLabels() {
                return labels;
            }

            public void setLabels(Labels labels) {
                this.labels = labels;
            }
        }

        // If this is set, this resource was dynamically reserved by an
        // operator or a framework. Otherwise, this resource is either unreserved
        // or statically reserved by an operator via the --resources flag.
        //
        // NOTE: Frameworks must not set this field if `reservations` is set.
        //       See the 'Resource Format' section for more details.
        //
        // TODO(mpark): Deprecate once `reservations` is no longer experimental.
        ReservationInfo reservation;

        // The stack of reservations. If this field is empty, it indicates that this
        // resource is unreserved. Otherwise, the resource is reserved. The first
        // `ReservationInfo` may have type `STATIC` or `DYNAMIC`, but the rest must
        // have `DYNAMIC`. One can create a new reservation on top of an existing
        // one by pushing a new `ReservationInfo` to the back. The last
        // `ReservationInfo` in this stack is the "current" reservation. The new
        // reservation's role must be a child of the current reservation's role.
        //
        // NOTE: Frameworks must not set this field if `reservation` is set.
        //       See the 'Resource Format' section for more details.
        //
        // TODO(mpark): Deprecate `role` and `reservation` once this is stable.
        List<ReservationInfo> reservations;  // EXPERIMENTAL.

        public static class DiskInfo {
            // Describes a persistent disk volume.
            //
            // A persistent disk volume will not be automatically garbage
            // collected if the task/executor/agent terminates, but will be
            // re-offered to the framework(s) belonging to the 'role'.
            //
            // NOTE: Currently, we do not allow persistent disk volumes
            // without a reservation (i.e., 'role' cannot be '*').
            public static class Persistence {
                // A unique ID for the persistent disk volume. This ID must be
                // unique per role on each agent. Although it is possible to use
                // the same ID on different agents in the cluster and to reuse
                // IDs after a volume with that ID has been destroyed, both
                // practices are discouraged.
                String id;

                // This field indicates the principal of the operator or
                // framework that created this volume. It is used in conjunction
                // with the "destroy" ACL to determine whether an entity
                // attempting to destroy the volume is permitted to do so.
                //
                // NOTE: This field should match the FrameworkInfo.principal of
                // the framework that created the volume.
                String principal;

                public String getId() {
                    return id;
                }

                public void setId(String id) {
                    this.id = id;
                }

                public String getPrincipal() {
                    return principal;
                }

                public void setPrincipal(String principal) {
                    this.principal = principal;
                }
            }

            Persistence persistence;

            // Describes how this disk resource will be mounted in the
            // container. If not set, the disk resource will be used as the
            // sandbox. Otherwise, it will be mounted according to the
            // 'container_path' inside 'volume'. The 'host_path' inside
            // 'volume' is ignored.
            // NOTE: If 'volume' is set but 'persistence' is not set, the
            // volume will be automatically garbage collected after
            // task/executor terminates. Currently, if 'persistence' is set,
            // 'volume' must be set.
            Volume volume;

            // Describes where a disk originates from.
            public static class Source {
                public enum Type {
                    UNKNOWN,
                    PATH,
                    MOUNT,
                    BLOCK,
                    RAW
                }

                // A folder that can be located on a separate disk device. This
                // can be shared and carved up as necessary between frameworks.
                public static class Path {
                    // Path to the folder (e.g., /mnt/raid/disk0). If the path is a
                    // relative path, it is relative to the agent work directory.
                    String root;

                    public String getRoot() {
                        return root;
                    }

                    public void setRoot(String root) {
                        this.root = root;
                    }
                }

                // A mounted file-system set up by the Agent administrator. This
                // can only be used exclusively: a framework cannot accept a
                // partial amount of this disk.
                public static class Mount {
                    // Path to mount point (e.g., /mnt/raid/disk0). If the path is a
                    // relative path, it is relative to the agent work directory.
                    String root;

                    public String getRoot() {
                        return root;
                    }

                    public void setRoot(String root) {
                        this.root = root;
                    }
                }

                Type type;
                Path path;
                Mount mount;

                // An identifier for this source. This field maps onto CSI
                // volume IDs and is not expected to be set by frameworks.
                String id; // EXPERIMENTAL.

                // Additional metadata for this source. This field maps onto CSI
                // volume metadata and is not expected to be set by frameworks.
                Labels metadata; // EXPERIMENTAL.

                // This field serves as an indirection to a set of storage
                // vendor specific disk parameters which describe the properties
                // of the disk. The operator will setup mappings between a
                // profile name to a set of vendor specific disk parameters. And
                // the framework will do disk selection based on profile names,
                // instead of vendor specific disk parameters.
                //
                // Also see the DiskProfile module.
                String profile; // EXPERIMENTAL.

                public Type getType() {
                    return type;
                }

                public void setType(Type type) {
                    this.type = type;
                }

                public Path getPath() {
                    return path;
                }

                public void setPath(Path path) {
                    this.path = path;
                }

                public Mount getMount() {
                    return mount;
                }

                public void setMount(Mount mount) {
                    this.mount = mount;
                }

                public String getId() {
                    return id;
                }

                public void setId(String id) {
                    this.id = id;
                }

                public Labels getMetadata() {
                    return metadata;
                }

                public void setMetadata(Labels metadata) {
                    this.metadata = metadata;
                }

                public String getProfile() {
                    return profile;
                }

                public void setProfile(String profile) {
                    this.profile = profile;
                }
            }

            Source source;

            public Persistence getPersistence() {
                return persistence;
            }

            public void setPersistence(Persistence persistence) {
                this.persistence = persistence;
            }

            public Volume getVolume() {
                return volume;
            }

            public void setVolume(Volume volume) {
                this.volume = volume;
            }

            public Source getSource() {
                return source;
            }

            public void setSource(Source source) {
                this.source = source;
            }
        }

        DiskInfo disk;

        public static class RevocableInfo {}

        // If this is set, the resources are revocable, i.e., any tasks or
        // executors launched using these resources could get preempted or
        // throttled at any time. This could be used by frameworks to run
        // best effort tasks that do not need strict uptime or performance
        // guarantees. Note that if this is set, 'disk' or 'reservation'
        // cannot be set.
        RevocableInfo revocable;

        // Allow the resource to be shared across tasks.
        public static class SharedInfo {}

        // If this is set, the resources are shared, i.e. multiple tasks
        // can be launched using this resource and all of them shall refer
        // to the same physical resource on the cluster. Note that only
        // persistent volumes can be shared currently.
        SharedInfo shared;

        public ResourceProviderID getProvider_id() {
            return provider_id;
        }

        public void setProvider_id(ResourceProviderID provider_id) {
            this.provider_id = provider_id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Value.Type getType() {
            return type;
        }

        public void setType(Value.Type type) {
            this.type = type;
        }

        public Value.Scalar getScalar() {
            return scalar;
        }

        public void setScalar(Value.Scalar scalar) {
            this.scalar = scalar;
        }

        public Value.Ranges getRanges() {
            return ranges;
        }

        public void setRanges(Value.Ranges ranges) {
            this.ranges = ranges;
        }

        public Value.Set getSet() {
            return set;
        }

        public void setSet(Value.Set set) {
            this.set = set;
        }

        public String getRole() {
            return role;
        }

        public void setRole(String role) {
            this.role = role;
        }

        public AllocationInfo getAllocation_info() {
            return allocation_info;
        }

        public void setAllocation_info(AllocationInfo allocation_info) {
            this.allocation_info = allocation_info;
        }

        public ReservationInfo getReservation() {
            return reservation;
        }

        public void setReservation(ReservationInfo reservation) {
            this.reservation = reservation;
        }

        public List<ReservationInfo> getReservations() {
            return reservations;
        }

        public void setReservations(List<ReservationInfo> reservations) {
            this.reservations = reservations;
        }

        public DiskInfo getDisk() {
            return disk;
        }

        public void setDisk(DiskInfo disk) {
            this.disk = disk;
        }

        public RevocableInfo getRevocable() {
            return revocable;
        }

        public void setRevocable(RevocableInfo revocable) {
            this.revocable = revocable;
        }

        public SharedInfo getShared() {
            return shared;
        }

        public void setShared(SharedInfo shared) {
            this.shared = shared;
        }
    }


    /**
     * When the network bandwidth caps are enabled and the container
     * is over its limit, outbound packets may be either delayed or
     * dropped completely either because it exceeds the maximum bandwidth
     * allocation for a single container (the cap) or because the combined
     * network traffic of multiple containers on the host exceeds the
     * transmit capacity of the host (the share). We can report the
     * following statistics for each of these conditions exported directly
     * from the Linux Traffic Control Queueing Discipline.
     *
     * id         : name of the limiter, e.g. 'tx_bw_cap'
     * backlog    : number of packets currently delayed
     * byte[]      : total byte[] seen
     * drops      : number of packets dropped in total
     * overlimits : number of packets which exceeded allocation
     * packets    : total packets seen
     * qlen       : number of packets currently queued
     * rate_bps   : throughput in byte[]/sec
     * rate_pps   : throughput in packets/sec
     * requeues   : number of times a packet has been delayed due to
     *              locking or device contention issues
     *
     * More information on the operation of Linux Traffic Control can be
     * found at http://www.lartc.org/lartc.html.
     */
    public static class TrafficControlStatistics {
        String id;
        Integer backlog;
        Integer bytes;
        Integer drops;
        Integer overlimits;
        Integer packets;
        Integer qlen;
        Integer ratebps;
        Integer ratepps;
        Integer requeues0;
    }


    public static class IpStatistics {
        Integer Forwarding;
        Integer DefaultTTL;
        Integer InReceives;
        Integer InHdrErrors;
        Integer InAddrErrors;
        Integer ForwDatagrams;
        Integer InUnknownProtos;
        Integer InDiscards;
        Integer InDelivers;
        Integer OutRequests0;
        Integer OutDiscards1;
        Integer OutNoRoutes2;
        Integer ReasmTimeout3;
        Integer ReasmReqds4;
        Integer ReasmOKs5;
        Integer ReasmFails6;
        Integer FragOKs7;
        Integer FragFails8;
        Integer FragCreates9;
    }


    public static class IcmpStatistics {
        Integer InMsgs;
        Integer InErrors;
        Integer InCsumErrors;
        Integer InDestUnreachs;
        Integer InTimeExcds;
        Integer InParmProbs;
        Integer InSrcQuenchs;
        Integer InRedirects;
        Integer InEchos;
        Integer InEchoReps0;
        Integer InTimestamps1;
        Integer InTimestampReps2;
        Integer InAddrMasks3;
        Integer InAddrMaskReps4;
        Integer OutMsgs5;
        Integer OutErrors6;
        Integer OutDestUnreachs7;
        Integer OutTimeExcds8;
        Integer OutParmProbs9;
        Integer OutSrcQuenchs0;
        Integer OutRedirects1;
        Integer OutEchos2;
        Integer OutEchoReps3;
        Integer OutTimestamps4;
        Integer OutTimestampReps5;
        Integer OutAddrMasks6;
        Integer OutAddrMaskReps7;
    }


    public static class TcpStatistics {
        Integer RtoAlgorithm;
        Integer RtoMin;
        Integer RtoMax;
        Integer MaxConn;
        Integer ActiveOpens;
        Integer PassiveOpens;
        Integer AttemptFails;
        Integer EstabResets;
        Integer CurrEstab;
        Integer InSegs0;
        Integer OutSegs1;
        Integer RetransSegs2;
        Integer InErrs3;
        Integer OutRsts4;
        Integer InCsumErrors5;
    }


    public static class UdpStatistics {
        Integer InDatagrams;
        Integer NoPorts;
        Integer InErrors;
        Integer OutDatagrams;
        Integer RcvbufErrors;
        Integer SndbufErrors;
        Integer InCsumErrors;
        Integer IgnoredMulti;
    }


    public static class SNMPStatistics {
        IpStatistics ip_stats;
        IcmpStatistics icmp_stats;
        TcpStatistics tcp_stats;
        UdpStatistics udp_stats;
    }


    public static class DiskStatistics {
        Resource.DiskInfo.Source source;
        Resource.DiskInfo.Persistence persistence;
        Integer limit_byte[];
        Integer used_byte[];
    }


    /**
     * A snapshot of resource usage statistics.
     */
    public static class ResourceStatistics {
        Double timestamp; // Snapshot time, in seconds since the Epoch.

        Integer processes0;
        Integer threads1;

        // CPU Usage Information:
        // Total CPU time spent in user mode, and kernel mode.
        Double cpus_user_time_secs;
        Double cpus_system_time_secs;

        // Number of CPUs allocated.
        Double cpus_limit;

        // cpu.stat on process throttling (for contention issues).
        Integer cpus_nr_periods;
        Integer cpus_nr_throttled;
        Double cpus_throttled_time_secs;

        // Memory Usage Information:

        // mem_total_byte[] was added in 0.23.0 to represent the total memory
        // of a process in RAM (as opposed to in Swap). This was previously
        // reported as mem_rss_byte[], which was also changed in 0.23.0 to
        // represent only the anonymous memory usage, to keep in sync with
        // Linux kernel's (arguably erroneous) use of terminology.
        Integer mem_total_bytes;

        // Total memory + swap usage. This is set if swap is enabled.
        Integer mem_total_memsw_bytes;

        // Hard memory limit for a container.
        Integer mem_limit_bytes;

        // Soft memory limit for a container.
        Integer mem_soft_limit_bytes;

        // Broken out memory usage information: pagecache, rss (anonymous),
        // mmaped files and swap.

        // TODO(chzhcn) mem_file_byte[] and mem_anon_byte[] are deprecated in
        // 0.23.0 and will be removed in 0.24.0.
        Integer mem_file_bytes;
        Integer mem_anon_bytes;

        // mem_cache_byte[] is added in 0.23.0 to represent page cache usage.
        Integer mem_cache_bytes;

        // Since 0.23.0, mem_rss_byte[] is changed to represent only
        // anonymous memory usage. Note that neither its requiredness, type,
        // name nor numeric tag has been changed.
        Integer mem_rss_bytes;

        Integer mem_mapped_file_bytes;
        // This is only set if swap is enabled.
        Integer mem_swap_bytes;
        Integer mem_unevictable_bytes;

        // Number of occurrences of different levels of memory pressure
        // events reported by memory cgroup. Pressure listening (re)starts
        // with these values set to 0 when agent (re)starts. See
        // https://www.kernel.org/doc/Documentation/cgroups/memory.txt for
        // more details.
        Integer mem_low_pressure_counter2;
        Integer mem_medium_pressure_counter3;
        Integer mem_critical_pressure_counter4;

        // Disk Usage Information for executor working directory.
        Integer disk_limit_bytes;
        Integer disk_used_bytes;

        // Per disk (resource) statistics.
        List<DiskStatistics> disk_statistics3;

        // Cgroups blkio statistics.
        CgroupInfo.Blkio.Statistics blkio_statistics4;

        // Perf statistics.
        PerfStatistics perf3;

        // Network Usage Information:
        Integer net_rx_packets;
        Integer net_rx_bytes;
        Integer net_rx_errors;
        Integer net_rx_dropped;
        Integer net_tx_packets;
        Integer net_tx_byte;
        Integer net_tx_errors;
        Integer net_tx_dropped;

        // The kernel keeps track of RTT (round-trip time) for its TCP
        // sockets. RTT is a way to tell the latency of a container.
        Double net_tcp_rtt_microsecs_p50;
        Double net_tcp_rtt_microsecs_p90;
        Double net_tcp_rtt_microsecs_p95;
        Double net_tcp_rtt_microsecs_p99;

        Double net_tcp_active_connections;
        Double net_tcp_time_wait_connections;

        // Network traffic flowing into or out of a container can be delayed
        // or dropped due to congestion or policy inside and outside the
        // container.
        List<TrafficControlStatistics> net_traffic_control_statistics;

        // Network SNMP statistics for each container.
        SNMPStatistics net_snmp_statistics;
    }


    /**
     * Describes a snapshot of the resource usage for executors.
     */
    public static class ResourceUsage {
        public static class Executor {
            ExecutorInfo executor_info;

            // This includes resources used by the executor itself
            // as well as its active tasks.
            List<Resource> allocated;

            // Current resource usage. If absent, the containerizer
            // cannot provide resource usage.
            ResourceStatistics statistics;

            // The container id for the executor specified in the executor_info field.
            ContainerID container_id;

            public static class Task {
                String name;
                TaskID id;
                List<Resource> resources;
                Labels labels;
            }

            // Non-terminal tasks.
            List<Task> tasks;
        }

        List<Executor> executors;

        // Agent's total resources including checkpointed dynamic
        // reservations and persistent volumes.
        List<Resource> total;
    }


    /**
     * Describes a sample of events from "perf stat". Only available on
     * Linux.
     *
     * NOTE: Each  field matches the name of a perf event (see
     * "perf list") with the following changes:
     * 1. Names are downcased.
     * 2. Hyphens ('-') are replaced with underscores ('_').
     * 3. Events with alternate names use the name "perf stat" returns,
     *    e.g., for the event "cycles OR cpu-cycles" perf always returns
     *    cycles.
     */
    public static class PerfStatistics {
        Double timestamp; // Start of sample interval, in seconds since the Epoch.
        Double duration;  // Duration of sample interval, in seconds.

        // Hardware event.
        Integer cycles;
        Integer stalled_cycles_frontend;
        Integer stalled_cycles_backend;
        Integer instructions;
        Integer cache_references;
        Integer cache_misses;
        Integer branches;
        Integer branch_misses;
        Integer bus_cycles;
        Integer ref_cycles;

        // Software event.
        Double cpu_clock;
        Double task_clock;
        Integer page_faults;
        Integer minor_faults;
        Integer major_faults;
        Integer context_switches;
        Integer cpu_migrations;
        Integer alignment_faults;
        Integer emulation_faults;

        // Hardware cache event.
        Integer l1_dcache_loads;
        Integer l1_dcache_load_misses;
        Integer l1_dcache_stores;
        Integer l1_dcache_store_misses;
        Integer l1_dcache_prefetches;
        Integer l1_dcache_prefetch_misses;
        Integer l1_icache_loads;
        Integer l1_icache_load_misses;
        Integer l1_icache_prefetches;
        Integer l1_icache_prefetch_misses;
        Integer llc_loads;
        Integer llc_load_misses;
        Integer llc_stores;
        Integer llc_store_misses;
        Integer llc_prefetches;
        Integer llc_prefetch_misses;
        Integer dtlb_loads;
        Integer dtlb_load_misses;
        Integer dtlb_stores;
        Integer dtlb_store_misses;
        Integer dtlb_prefetches;
        Integer dtlb_prefetch_misses;
        Integer itlb_loads;
        Integer itlb_load_misses;
        Integer branch_loads;
        Integer branch_load_misses;
        Integer node_loads;
        Integer node_load_misses;
        Integer node_stores;
        Integer node_store_misses;
        Integer node_prefetches;
        Integer node_prefetch_misses;
    }


    /**
     * Describes a request for resources that can be used by a framework
     * to proactively influence the allocator.  If 'agent_id' is provided
     * then this request is assumed to only apply to resources on that
     * agent.
     */
    public static class Request {
        AgentID agent_id;
        List<Resource> resources;
    }


    /**
     * Describes some resources available on an agent. An offer only
     * contains resources from a single agent.
     */
    public static class Offer {
        OfferID id;
        FrameworkID framework_id;
        AgentID agent_id;
        String hostname;

        // URL for reaching the agent running on the host.
        URL url;

        // The domain of the agent.
        DomainInfo domain;

        List<Resource> resources;
        List<Attribute> attributes;
        List<ExecutorID> executor_ids;

        // Signifies that the resources in this Offer may be unavailable during
        // the given interval.  Any tasks launched using these resources may be
        // killed when the interval arrives.  For example, these resources may be
        // part of a planned maintenance schedule.
        //
        // This field only provides information about a planned unavailability.
        // The unavailability interval may not necessarily start at exactly this
        // interval, nor last for exactly the duration of this interval.
        // The unavailability may also be forever!  See comments in
        // `Unavailability` for more details.
        Unavailability unavailability;

        // An offer represents resources allocated to *one* of the
        // roles managed by the scheduler. (Therefore, each
        // `Offer.resources[i].allocation_info` will match the
        // top level `Offer.allocation_info`).
        Resource.AllocationInfo allocation_info;

        // Defines an operation that can be performed against offers.
        public static class Operation {
            public enum Type {
                UNKNOWN,
                LAUNCH,
                LAUNCH_GROUP,
                RESERVE,
                UNRESERVE,
                CREATE,
                DESTROY,
                CREATE_VOLUME,
                DESTROY_VOLUME,
                CREATE_BLOCK,
                DESTROY_BLOCK0
            }

            // TODO(vinod): Deprecate this in favor of `LaunchGroup` below.
            public static class Launch {
                List<TaskInfo> task_infos;

                public List<TaskInfo> getTask_infos() {
                    return task_infos;
                }

                public void setTask_infos(List<TaskInfo> task_infos) {
                    this.task_infos = task_infos;
                }
            }

            // Unlike `Launch` above, all the tasks in a `task_group` are
            // atomically delivered to an executor.
            //
            // `NetworkInfo` set on executor will be shared by all tasks in
            // the task group.
            //
            // TODO(vinod): Any volumes set on executor could be used by a
            // task by explicitly setting `Volume.source` in its resources.
            public static class LaunchGroup {
                ExecutorInfo executor;
                TaskGroupInfo task_group;
            }

            public static class Reserve {
                List<Resource> resources;
            }

            public static class Unreserve {
                List<Resource> resources;
            }

            public static class Create {
                List<Resource> volumes;
            }

            public static class Destroy {
                List<Resource> volumes;
            }

            public static class CreateVolume {
                Resource source;
                Resource.DiskInfo.Source.Type target_type;
            }

            public static class DestroyVolume {
                Resource volume;
            }

            public static class CreateBlock {
                Resource source;
            }

            public static class DestroyBlock {
                Resource block;
            }

            Type type;

            // NOTE: The `id` field will allow frameworks to indicate that they wish to
            // receive feedback about an operation. Since this feature is not yet
            // implemented, the `id` field should NOT be set at present. See MESOS-8054.
            OperationID id; // Experimental.

            Launch launch;
            LaunchGroup launch_group;
            Reserve reserve;
            Unreserve unreserve;
            Create create;
            Destroy destroy;
            CreateVolume create_volume;
            DestroyVolume destroy_volume;
            CreateBlock create_block;
            DestroyBlock destroy_block;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }

            public OperationID getId() {
                return id;
            }

            public void setId(OperationID id) {
                this.id = id;
            }

            public Launch getLaunch() {
                return launch;
            }

            public void setLaunch(Launch launch) {
                this.launch = launch;
            }

            public LaunchGroup getLaunch_group() {
                return launch_group;
            }

            public void setLaunch_group(LaunchGroup launch_group) {
                this.launch_group = launch_group;
            }

            public Reserve getReserve() {
                return reserve;
            }

            public void setReserve(Reserve reserve) {
                this.reserve = reserve;
            }

            public Unreserve getUnreserve() {
                return unreserve;
            }

            public void setUnreserve(Unreserve unreserve) {
                this.unreserve = unreserve;
            }

            public Create getCreate() {
                return create;
            }

            public void setCreate(Create create) {
                this.create = create;
            }

            public Destroy getDestroy() {
                return destroy;
            }

            public void setDestroy(Destroy destroy) {
                this.destroy = destroy;
            }

            public CreateVolume getCreate_volume() {
                return create_volume;
            }

            public void setCreate_volume(CreateVolume create_volume) {
                this.create_volume = create_volume;
            }

            public DestroyVolume getDestroy_volume() {
                return destroy_volume;
            }

            public void setDestroy_volume(DestroyVolume destroy_volume) {
                this.destroy_volume = destroy_volume;
            }

            public CreateBlock getCreate_block() {
                return create_block;
            }

            public void setCreate_block(CreateBlock create_block) {
                this.create_block = create_block;
            }

            public DestroyBlock getDestroy_block() {
                return destroy_block;
            }

            public void setDestroy_block(DestroyBlock destroy_block) {
                this.destroy_block = destroy_block;
            }
        }

        public OfferID getId() {
            return id;
        }

        public void setId(OfferID id) {
            this.id = id;
        }

        public FrameworkID getFramework_id() {
            return framework_id;
        }

        public void setFramework_id(FrameworkID framework_id) {
            this.framework_id = framework_id;
        }

        public AgentID getAgent_id() {
            return agent_id;
        }

        public void setAgent_id(AgentID agent_id) {
            this.agent_id = agent_id;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public URL getUrl() {
            return url;
        }

        public void setUrl(URL url) {
            this.url = url;
        }

        public DomainInfo getDomain() {
            return domain;
        }

        public void setDomain(DomainInfo domain) {
            this.domain = domain;
        }

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }

        public List<Attribute> getAttributes() {
            return attributes;
        }

        public void setAttributes(List<Attribute> attributes) {
            this.attributes = attributes;
        }

        public List<ExecutorID> getExecutor_ids() {
            return executor_ids;
        }

        public void setExecutor_ids(List<ExecutorID> executor_ids) {
            this.executor_ids = executor_ids;
        }

        public Unavailability getUnavailability() {
            return unavailability;
        }

        public void setUnavailability(Unavailability unavailability) {
            this.unavailability = unavailability;
        }

        public Resource.AllocationInfo getAllocation_info() {
            return allocation_info;
        }

        public void setAllocation_info(Resource.AllocationInfo allocation_info) {
            this.allocation_info = allocation_info;
        }
    }


    /**
     * A request to return some resources occupied by a framework.
     */
    public static class InverseOffer {
        // This is the same OfferID as found in normal offers, which allows
        // re-use of some of the OfferID-only messages.
        OfferID id;

        // URL for reaching the agent running on the host.  This enables some
        // optimizations as described in MESOS-3012, such as allowing the
        // scheduler driver to bypass the master and talk directly with an agent.
        URL url;

        // The framework that should release its resources.
        // If no specifics are provided (i.e. which agent), all the framework's
        // resources are requested back.
        FrameworkID framework_id;

        // Specified if the resources need to be released from a particular agent.
        // All the framework's resources on this agent are requested back,
        // unless further qualified by the `resources` field.
        AgentID agent_id;

        // This InverseOffer represents a planned unavailability event in the
        // specified interval.  Any tasks running on the given framework or agent
        // may be killed when the interval arrives.  Therefore, frameworks should
        // aim to gracefully terminate tasks prior to the arrival of the interval.
        //
        // For reserved resources, the resources are expected to be returned to the
        // framework after the unavailability interval.  This is an expectation,
        // not a guarantee.  For example, if the unavailability duration is not set,
        // the resources may be removed permanently.
        //
        // For other resources, there is no guarantee that requested resources will
        // be returned after the unavailability interval.  The allocator has no
        // obligation to re-offer these resources to the prior framework after
        // the unavailability.
        Unavailability unavailability;

        // A list of resources being requested back from the framework,
        // on the agent identified by `agent_id`.  If no resources are specified
        // then all resources are being requested back.  For the purpose of
        // maintenance, this field is always empty (maintenance always requests
        // all resources back).
        List<Resource> resources;

        // TODO(josephw): Add additional options for narrowing down the resources
        // being requested back.  Such as specific executors, tasks, etc.
    }


    /**
     * Describes a task. Passed from the scheduler all the way to an
     * executor (see SchedulerDriver::launchTasks and
     * Executor::launchTask). Either ExecutorInfo or CommandInfo should be set.
     * A different executor can be used to launch this task, and subsequent tasks
     * meant for the same executor can reuse the same ExecutorInfo struct.
     */
    public static class TaskInfo {
        String name;
        TaskID task_id;
        AgentID agent_id;
        List<Resource> resources;
        ExecutorInfo executor;
        CommandInfo command;

        // Task provided with a container will launch the container as part
        // of this task paired with the task's CommandInfo.
        ContainerInfo container;

        // A health check for the task. Implemented for executor-less
        // command-based tasks. For tasks that specify an executor, it is
        // the executor's responsibility to implement the health checking.
        HealthCheck health_check;

        // A general check for the task. Implemented for all built-in executors.
        // For tasks that specify an executor, it is the executor's responsibility
        // to implement checking support. Executors should (all built-in executors
        // will) neither interpret nor act on the check's result.
        //
        // NOTE: Check support in built-in executors is experimental.
        //
        // TODO(alexr): Consider supporting multiple checks per task.
        CheckInfo check;

        // A kill policy for the task. Implemented for executor-less
        // command-based and docker tasks. For tasks that specify an
        // executor, it is the executor's responsibility to implement
        // the kill policy.
        KillPolicy kill_policy;

        byte[] data;

        // Labels are free-form key value pairs which are exposed through
        // master and agent endpoints. Labels will not be interpreted or
        // acted upon by Mesos itself. As opposed to the data field, labels
        // will be kept in memory on master and agent processes. Therefore,
        // labels should be used to tag tasks with light-weight meta-data.
        // Labels should not contain duplicate key-value pairs.
        Labels labels;

        // Service discovery information for the task. It is not interpreted
        // or acted upon by Mesos. It is up to a service discovery system
        // to use this information as needed and to handle tasks without
        // service discovery information.
        DiscoveryInfo discovery;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public TaskID getTask_id() {
            return task_id;
        }

        public void setTask_id(TaskID task_id) {
            this.task_id = task_id;
        }

        public AgentID getAgent_id() {
            return agent_id;
        }

        public void setAgent_id(AgentID agent_id) {
            this.agent_id = agent_id;
        }

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }

        public ExecutorInfo getExecutor() {
            return executor;
        }

        public void setExecutor(ExecutorInfo executor) {
            this.executor = executor;
        }

        public CommandInfo getCommand() {
            return command;
        }

        public void setCommand(CommandInfo command) {
            this.command = command;
        }

        public ContainerInfo getContainer() {
            return container;
        }

        public void setContainer(ContainerInfo container) {
            this.container = container;
        }

        public HealthCheck getHealth_check() {
            return health_check;
        }

        public void setHealth_check(HealthCheck health_check) {
            this.health_check = health_check;
        }

        public CheckInfo getCheck() {
            return check;
        }

        public void setCheck(CheckInfo check) {
            this.check = check;
        }

        public KillPolicy getKill_policy() {
            return kill_policy;
        }

        public void setKill_policy(KillPolicy kill_policy) {
            this.kill_policy = kill_policy;
        }

        public byte[] getData() {
            return data;
        }

        public void setData(byte[] data) {
            this.data = data;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }

        public DiscoveryInfo getDiscovery() {
            return discovery;
        }

        public void setDiscovery(DiscoveryInfo discovery) {
            this.discovery = discovery;
        }
    }


    /**
     * Describes a group of tasks that belong to an executor. The
     * executor will receive the task group in a single public static class to
     * allow the group to be launched "atomically".
     *
     * NOTES:
     * 1) `NetworkInfo` must not be set inside task's `ContainerInfo`.
     * 2) `TaskInfo.executor` doesn't need to set. If set, it should match
     *    `LaunchGroup.executor`.
     */
    public static class TaskGroupInfo {
        List<TaskInfo> tasks;

        public List<TaskInfo> getTasks() {
            return tasks;
        }

        public void setTasks(List<TaskInfo> tasks) {
            this.tasks = tasks;
        }
    }


// TODO(bmahler): Add executor_uuid here, and send it to the master. This will
// allow us to expose executor work directories for tasks in the webui when
// looking from the master level. Currently only the agent knows which run the
// task belongs to.
    /**
     * Describes a task, similar to `TaskInfo`.
     *
     * `Task` is used in some of the Mesos messages found below.
     * `Task` is used instead of `TaskInfo` if:
     *   1) we need additional IDs, such as a specific
     *      framework, executor, or agent; or
     *   2) we do not need the additional data, such as the command run by the
     *      task or the health checks.  These additional fields may be large and
     *      unnecessary for some Mesos messages.
     *
     * `Task` is generally constructed from a `TaskInfo`.  See protobuf::createTask.
     */
    public static class Task {
        String name;
        TaskID task_id;
        FrameworkID framework_id;
        ExecutorID executor_id;
        AgentID agent_id;
        TaskState state; // Latest state of the task.
        List<Resource> resources;
        List<TaskStatus> statuses;

        // These fields correspond to the state and uuid of the latest
        // status update forwarded to the master.
        // NOTE: Either both the fields must be set or both must be unset.
        TaskState status_update_state;
        byte[] status_update_uuid;

        Labels labels;

        // Service discovery information for the task. It is not interpreted
        // or acted upon by Mesos. It is up to a service discovery system
        // to use this information as needed and to handle tasks without
        // service discovery information.
        DiscoveryInfo discovery;

        // Container information for the task.
        ContainerInfo container;

        // Specific user under which task is running.
        String user;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public TaskID getTask_id() {
            return task_id;
        }

        public void setTask_id(TaskID task_id) {
            this.task_id = task_id;
        }

        public FrameworkID getFramework_id() {
            return framework_id;
        }

        public void setFramework_id(FrameworkID framework_id) {
            this.framework_id = framework_id;
        }

        public ExecutorID getExecutor_id() {
            return executor_id;
        }

        public void setExecutor_id(ExecutorID executor_id) {
            this.executor_id = executor_id;
        }

        public AgentID getAgent_id() {
            return agent_id;
        }

        public void setAgent_id(AgentID agent_id) {
            this.agent_id = agent_id;
        }

        public TaskState getState() {
            return state;
        }

        public void setState(TaskState state) {
            this.state = state;
        }

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }

        public List<TaskStatus> getStatuses() {
            return statuses;
        }

        public void setStatuses(List<TaskStatus> statuses) {
            this.statuses = statuses;
        }

        public TaskState getStatus_update_state() {
            return status_update_state;
        }

        public void setStatus_update_state(TaskState status_update_state) {
            this.status_update_state = status_update_state;
        }

        public byte[] getStatus_update_uuid() {
            return status_update_uuid;
        }

        public void setStatus_update_uuid(byte[] status_update_uuid) {
            this.status_update_uuid = status_update_uuid;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }

        public DiscoveryInfo getDiscovery() {
            return discovery;
        }

        public void setDiscovery(DiscoveryInfo discovery) {
            this.discovery = discovery;
        }

        public ContainerInfo getContainer() {
            return container;
        }

        public void setContainer(ContainerInfo container) {
            this.container = container;
        }

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }
    }


    /**
     * Describes possible task states. IMPORTANT: Mesos assumes tasks that
     * enter terminal states (see below) imply the task is no longer
     * running and thus clean up any thing associated with the task
     * (ultimately offering any resources being consumed by that task to
     * another task).
     */
    public enum TaskState {
        TASK_STAGING,  // Initial state. Framework status updates should not use.
        TASK_STARTING, // The task is being launched by the executor.
        TASK_RUNNING,

        // NOTE: This should only be sent when the framework has
        // the TASK_KILLING_STATE capability.
        TASK_KILLING,  // The task is being killed by the executor.

        // The task finished successfully on its own without external interference.
        TASK_FINISHED, // TERMINAL.

        TASK_FAILED,   // TERMINAL: The task failed to finish successfully.
        TASK_KILLED,   // TERMINAL: The task was killed by the executor.
        TASK_ERROR,    // TERMINAL: The task description contains an error.

        // In Mesos 1.3, this will only be sent when the framework does NOT
        // opt-in to the PARTITION_AWARE capability.
        //
        // NOTE: This state is not always terminal. For example, tasks might
        // transition from TASK_LOST to TASK_RUNNING or other states when a
        // partitioned agent re-registers.
        TASK_LOST,     // The task failed but can be rescheduled.

        // The following task states are only sent when the framework
        // opts-in to the PARTITION_AWARE capability.

        // The task failed to launch because of a transient error. The
        // task's executor never started running. Unlike TASK_ERROR, the
        // task description is valid -- attempting to launch the task again
        // may be successful.
        TASK_DROPPED,  // TERMINAL.

        // The task was running on an agent that has lost contact with the
        // master, typically due to a network failure or partition. The task
        // may or may not still be running.
        TASK_UNREACHABLE,

        // The task is no longer running. This can occur if the agent has
        // been terminated along with all of its tasks (e.g., the host that
        // was running the agent was rebooted). It might also occur if the
        // task was terminated due to an agent or containerizer error, or if
        // the task was preempted by the QoS controller in an
        // oversubscription scenario.
        TASK_GONE,    // TERMINAL.

        // The task was running on an agent that the master cannot contact;
        // the operator has asserted that the agent has been shutdown, but
        // this has not been directly confirmed by the master. If the
        // operator is correct, the task is not running and this is a
        // terminal state; if the operator is mistaken, the task may still
        // be running and might return to RUNNING in the future.
        TASK_GONE_BY_OPERATOR,

        // The master has no knowledge of the task. This is typically
        // because either (a) the master never had knowledge of the task, or
        // (b) the master forgot about the task because it garbage collected
        // its metadata about the task. The task may or may not still be
        // running.
        TASK_UNKNOWN
    }


    /**
     * Describes a resource limitation that caused a task failure.
     */
    public static class TaskResourceLimitation {
        // This field contains the resource whose limits were violated.
        //
        // NOTE: 'Resources' is used here because the resource may span
        // multiple roles (e.g. `"mem(*):1;mem(role):2"`).
        List<Resource> resources;

        public List<Resource> getResources() {
            return resources;
        }

        public void setResources(List<Resource> resources) {
            this.resources = resources;
        }
    }


    /**
     * Describes a UUID.
     */
    public static class UUID {
        byte[] value;

        public byte[] getValue() {
            return value;
        }

        public void setValue(byte[] value) {
            this.value = value;
        }
    }


    /**
     * Describes an operation, similar to `Offer.Operation`, with
     * some additional information.
     */
    public static class Operation {
        FrameworkID framework_id;
        AgentID agent_id;
        Offer.Operation info;
        OperationStatus latest_status;

        // All the statuses known to this operation. Some of the statuses in this
        // list might not have been acknowledged yet. The statuses are ordered.
        List<OperationStatus> statuses;

        // This is the internal UUID for the operation, which is kept independently
        // from the framework-specified operation ID, which is .
        UUID uuid;

        public FrameworkID getFramework_id() {
            return framework_id;
        }

        public void setFramework_id(FrameworkID framework_id) {
            this.framework_id = framework_id;
        }

        public AgentID getAgent_id() {
            return agent_id;
        }

        public void setAgent_id(AgentID agent_id) {
            this.agent_id = agent_id;
        }

        public Offer.Operation getInfo() {
            return info;
        }

        public void setInfo(Offer.Operation info) {
            this.info = info;
        }

        public OperationStatus getLatest_status() {
            return latest_status;
        }

        public void setLatest_status(OperationStatus latest_status) {
            this.latest_status = latest_status;
        }

        public List<OperationStatus> getStatuses() {
            return statuses;
        }

        public void setStatuses(List<OperationStatus> statuses) {
            this.statuses = statuses;
        }

        public UUID getUuid() {
            return uuid;
        }

        public void setUuid(UUID uuid) {
            this.uuid = uuid;
        }
    }


    /**
     * Describes possible operation states.
     */
    public enum OperationState {
        // Default value if the public enum is not set. See MESOS-4997.
        OPERATION_UNSUPPORTED,

        // Initial state.
        OPERATION_PENDING,

        // TERMINAL: The operation was successfully applied.
        OPERATION_FINISHED,

        // TERMINAL: The operation failed to apply.
        OPERATION_FAILED,

        // TERMINAL: The operation description contains an error.
        OPERATION_ERROR,

        // TERMINAL: The operation was dropped due to a transient error.
        OPERATION_DROPPED
    }


    /**
     * Describes the current status of an operation.
     */
    public static class OperationStatus {
        OperationID operation_id;
        OperationState state;
        String message;

        // Converted resources after applying the operation. This only
        // applies if the `state` is `OPERATION_FINISHED`.
        List<Resource> converted_resources;

        // Statuses that are delivered reliably to the scheduler will
        // include a `uuid`. The status is considered delivered once
        // it is acknowledged by the scheduler.
        byte[] uuid;

        public OperationID getOperation_id() {
            return operation_id;
        }

        public void setOperation_id(OperationID operation_id) {
            this.operation_id = operation_id;
        }

        public OperationState getState() {
            return state;
        }

        public void setState(OperationState state) {
            this.state = state;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public List<Resource> getConverted_resources() {
            return converted_resources;
        }

        public void setConverted_resources(List<Resource> converted_resources) {
            this.converted_resources = converted_resources;
        }

        public byte[] getUuid() {
            return uuid;
        }

        public void setUuid(byte[] uuid) {
            this.uuid = uuid;
        }
    }


    /**
     * Describes the status of a check. Type and the corresponding field, i.e.,
     * `command` or `http` must be set. If the result of the check is not available
     * (e.g., the check timed out), these fields must contain empty messages, i.e.,
     * `exit_code` or `status_code` will be unset.
     *
     * NOTE: This API is unstable and the related feature is experimental.
     */
    public static class CheckStatusInfo {
        public static class Command {
            // Exit code of a command check. It is the result of calling
            // `WEXITSTATUS()` on `waitpid()` termination information on
            // Posix and calling `GetExitCodeProcess()` on Windows.
            Integer exit_code;
        }

        public static class Http {
            // HTTP status code of an HTTP check.
            Integer status_code;
        }

        public static class Tcp {
            // Whether a TCP connection succeeded.
            Boolean succeeded;
        }

        // TODO(alexr): Consider adding a `data` field, which can contain, e.g.,
        // truncated stdout/stderr output for command checks or HTTP response body
        // for HTTP checks. Alternatively, it can be an even shorter `message` field
        // containing the last line of stdout or Reason-Phrase of the status line of
        // the HTTP response.

        // The type of the check this status corresponds to.
        CheckInfo.Type type;

        // Status of a command check.
        Command command;

        // Status of an HTTP check.
        Http http;

        // Status of a TCP check.
        Tcp tcp;

        // TODO(alexr): Consider introducing a "last changed at" timestamp, since
        // task status update's timestamp may not correspond to the last check's
        // state, e.g., for reconciliation.

        // TODO(alexr): Consider introducing a `reason` public enum here to explicitly
        // distinguish between completed, delayed, and timed out checks.
    }


    /**
     * Describes the current status of a task.
     */
    public static class TaskStatus implements Serializable{
        // Describes the source of the task status update.
        public enum Source {
            SOURCE_MASTER,
            SOURCE_AGENT,
            SOURCE_EXECUTOR
        }

        // Detailed reason for the task status update.
        // Refer to docs/task-state-reasons.md for additional explanation.
        public enum Reason {
            // TODO(jieyu): The default value when a caller doesn't check for
            // presence is 0 and so ideally the 0 reason is not a valid one.
            // Since this is not used anywhere, consider removing this reason.
            REASON_COMMAND_EXECUTOR_FAILED,

            REASON_CONTAINER_LAUNCH_FAILED,
            REASON_CONTAINER_LIMITATION,
            REASON_CONTAINER_LIMITATION_DISK,
            REASON_CONTAINER_LIMITATION_MEMORY,
            REASON_CONTAINER_PREEMPTED,
            REASON_CONTAINER_UPDATE_FAILED,
            REASON_EXECUTOR_REGISTRATION_TIMEOUT,
            REASON_EXECUTOR_REREGISTRATION_TIMEOUT,
            REASON_EXECUTOR_TERMINATED,
            REASON_EXECUTOR_UNREGISTERED, // No longer used.
            REASON_FRAMEWORK_REMOVED,
            REASON_GC_ERROR,
            REASON_INVALID_FRAMEWORKID,
            REASON_INVALID_OFFERS,
            REASON_IO_SWITCHBOARD_EXITED,
            REASON_MASTER_DISCONNECTED,
            REASON_RECONCILIATION,
            REASON_RESOURCES_UNKNOWN,
            REASON_AGENT_DISCONNECTED,
            REASON_AGENT_REMOVED,
            REASON_AGENT_REMOVED_BY_OPERATOR,
            REASON_AGENT_REREGISTERED,
            REASON_AGENT_RESTARTED,
            REASON_AGENT_UNKNOWN,
            REASON_TASK_KILLED_DURING_LAUNCH,
            REASON_TASK_CHECK_STATUS_UPDATED,
            REASON_TASK_HEALTH_CHECK_STATUS_UPDATED,
            REASON_TASK_GROUP_INVALID,
            REASON_TASK_GROUP_UNAUTHORIZED,
            REASON_TASK_INVALID,
            REASON_TASK_UNAUTHORIZED,
            REASON_TASK_UNKNOWN
        }

        TaskID task_id;
        TaskState state;
        String message; // Possible public static class explaining state.
        Source source;
        Reason reason;
        byte[] data;
        AgentID agent_id;
        ExecutorID executor_id; // TODO(benh): Use in master/agent.
        Double timestamp;

        // Statuses that are delivered reliably to the scheduler will
        // include a 'uuid'. The status is considered delivered once
        // it is acknowledged by the scheduler. Schedulers can choose
        // to either explicitly acknowledge statuses or let the scheduler
        // driver implicitly acknowledge (default).
        //
        // TODO(bmahler): This is currently overwritten in the scheduler
        // driver and executor driver, but executors will need to set this
        // to a valid RFC-4122 UUID if using the HTTP API.
        byte[] uuid;

        // Describes whether the task has been determined to be healthy (true) or
        // unhealthy (false) according to the `health_check` field in `TaskInfo`.
        Boolean healthy;

        // Contains check status for the check specified in the corresponding
        // `TaskInfo`. If no check has been specified, this field must be
        // absent, otherwise it must be present even if the check status is
        // not available yet. If the status update is triggered for a different
        // reason than `REASON_TASK_CHECK_STATUS_UPDATED`, this field will contain
        // the last known value.
        //
        // NOTE: A check-related task status update is triggered if and only if
        // the value or presence of any field in `CheckStatusInfo` changes.
        //
        // NOTE: Check support in built-in executors is experimental.
        CheckStatusInfo check_status;

        // Labels are free-form key value pairs which are exposed through
        // master and agent endpoints. Labels will not be interpreted or
        // acted upon by Mesos itself. As opposed to the data field, labels
        // will be kept in memory on master and agent processes. Therefore,
        // labels should be used to tag TaskStatus public static class with light-weight
        // meta-data. Labels should not contain duplicate key-value pairs.
        Labels labels;

        // Container related information that is resolved dynamically such as
        // network address.
        ContainerStatus container_status;

        // The time (according to the master's clock) when the agent where
        // this task was running became unreachable. This is only set on
        // status updates for tasks running on agents that are unreachable
        // (e.g., partitioned away from the master).
        TimeInfo unreachable_time;

        // If the reason field indicates a container resource limitation,
        // this field ly contains additional information.
        TaskResourceLimitation limitation;

        public TaskID getTask_id() {
            return task_id;
        }

        public void setTask_id(TaskID task_id) {
            this.task_id = task_id;
        }

        public TaskState getState() {
            return state;
        }

        public void setState(TaskState state) {
            this.state = state;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }

        public Source getSource() {
            return source;
        }

        public void setSource(Source source) {
            this.source = source;
        }

        public Reason getReason() {
            return reason;
        }

        public void setReason(Reason reason) {
            this.reason = reason;
        }

        public byte[] getData() {
            return data;
        }

        public void setData(byte[] data) {
            this.data = data;
        }

        public AgentID getAgent_id() {
            return agent_id;
        }

        public void setAgent_id(AgentID agent_id) {
            this.agent_id = agent_id;
        }

        public ExecutorID getExecutor_id() {
            return executor_id;
        }

        public void setExecutor_id(ExecutorID executor_id) {
            this.executor_id = executor_id;
        }

        public Double getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(Double timestamp) {
            this.timestamp = timestamp;
        }

        public byte[] getUuid() {
            return uuid;
        }

        public void setUuid(byte[] uuid) {
            this.uuid = uuid;
        }

        public Boolean getHealthy() {
            return healthy;
        }

        public void setHealthy(Boolean healthy) {
            this.healthy = healthy;
        }

        public CheckStatusInfo getCheck_status() {
            return check_status;
        }

        public void setCheck_status(CheckStatusInfo check_status) {
            this.check_status = check_status;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }

        public ContainerStatus getContainer_status() {
            return container_status;
        }

        public void setContainer_status(ContainerStatus container_status) {
            this.container_status = container_status;
        }

        public TimeInfo getUnreachable_time() {
            return unreachable_time;
        }

        public void setUnreachable_time(TimeInfo unreachable_time) {
            this.unreachable_time = unreachable_time;
        }

        public TaskResourceLimitation getLimitation() {
            return limitation;
        }

        public void setLimitation(TaskResourceLimitation limitation) {
            this.limitation = limitation;
        }
    }


    /**
     * Describes possible filters that can be applied to unused resources
     * (see SchedulerDriver::launchTasks) to influence the allocator.
     */
    public static class Filters {
        // Time to consider unused resources refused. Note that all unused
        // resources will be considered refused and use the default value
        // (below) regardless of whether Filters was passed to
        // SchedulerDriver::launchTasks. You MUST pass Filters with this
        // field set to change this behavior (i.e., get another offer which
        // includes unused resources sooner or later than the default).
        //
        // If this field is set to a number of seconds greater than 31536000
        // (365 days), then the resources will be considered refused for 365
        // days. If it is set to a negative number, then the default value
        // will be used.
        Double refuse_seconds = 0.0;
    }


    /**
     * Describes a collection of environment variables. This is used with
     * CommandInfo in order to set environment variables before running a
     * command. The contents of each variable may be specified as a String
     * or a Secret; only one of `value` and `secret` must be set.
     */
    public static class Environment {
        public static class Variable {
            String name;

            public enum Type {
                UNKNOWN,
                VALUE,
                SECRET
            }

            // In Mesos 1.2, the `Environment.variables.value` public static class was made
            // . The default type for `Environment.variables.type` is now VALUE,
            // which requires `value` to be set, maintaining backward compatibility.
            //
            // TODO(greggomann): The default can be removed in Mesos 2.1 (MESOS-7134).
            Type type  = Type.VALUE;

            // Only one of `value` and `secret` must be set.
            String value;
            Secret secret;

            public String getName() {
                return name;
            }

            public void setName(String name) {
                this.name = name;
            }

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }

            public String getValue() {
                return value;
            }

            public void setValue(String value) {
                this.value = value;
            }

            public Secret getSecret() {
                return secret;
            }

            public void setSecret(Secret secret) {
                this.secret = secret;
            }
        }

        List<Variable> variables;

        public List<Variable> getVariables() {
            return variables;
        }

        public void setVariables(List<Variable> variables) {
            this.variables = variables;
        }
    }


    /**
     * A generic (key, value) pair used in various places for parameters.
     */
    public static class Parameter {
        String key;
        String value;

        public String getKey() {
            return key;
        }

        public void setKey(String key) {
            this.key = key;
        }

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }


    /**
     * Collection of Parameter.
     */
    public static class Parameters {
        List<Parameter> parameter;

        public List<Parameter> getParameter() {
            return parameter;
        }

        public void setParameter(List<Parameter> parameter) {
            this.parameter = parameter;
        }
    }


    /**
     * Credential used in various places for authentication and
     * authorization.
     *
     * NOTE: A 'principal' is different from 'FrameworkInfo.user'. The
     * former is used for authentication and authorization while the
     * latter is used to determine the default user under which the
     * framework's executors/tasks are run.
     */
    public static class Credential {
        String principal;
        String secret;
    }


    /**
     * Credentials used for framework authentication, HTTP authentication
     * (where the common 'username' and 'password' are captured as
     * 'principal' and 'secret' respectively), etc.
     */
    public static class Credentials {
        List<Credential> credentials;
    }


    /**
     * Secret used to pass privileged information. It is designed to provide
     * pass-by-value or pass-by-reference semantics, where the REFERENCE type can be
     * used by custom modules which interact with a secure back-end.
     */
    public static class Secret
    {
        public enum Type {
            UNKNOWN,
            REFERENCE,
            VALUE
        }

        // Can be used by modules to refer to a secret stored in a secure back-end.
        // The `key` field is provided to permit reference to a single value within a
        // secret containing arbitrary key-value pairs.
        //
        // For example, given a back-end secret store with a secret named
        // "my-secret" containing the following key-value pairs:
        //
        //   {
        //     "username": "my-user",
        //     "password": "my-password
        //   }
        //
        // the username could be referred to in a `Secret` by specifying
        // "my-secret" for the `name` and "username" for the `key`.
        public static class Reference
        {
            String name;
            String key;
        }

        // Used to pass the value of a secret.
        public static class Value
        {
            byte[] data;
        }

        Type type;

        // Only one of `reference` and `value` must be set.
        Reference reference;
        Value value;
    }


    /**
     * Rate (queries per second, QPS) limit for messages from a framework to master.
     * Strictly speaking they are the combined rate from all frameworks of the same
     * principal.
     */
    public static class RateLimit {
        // Leaving QPS unset gives it unlimited rate (i.e., not throttled),
        // which also implies unlimited capacity.
        Double qps;

        // Principal of framework(s) to be throttled. Should match
        // FrameworkInfo.principal and Credential.principal (if using authentication).
        String principal;

        // Max number of outstanding messages from frameworks of this principal
        // allowed by master before the next public static class is dropped and an error is sent
        // back to the sender. Messages received before the capacity is reached are
        // still going to be processed after the error is sent.
        // If unspecified, this principal is assigned unlimited capacity.
        // NOTE: This value is ignored if 'qps' is not set.
        Integer capacity;

        public Double getQps() {
            return qps;
        }

        public void setQps(Double qps) {
            this.qps = qps;
        }

        public String getPrincipal() {
            return principal;
        }

        public void setPrincipal(String principal) {
            this.principal = principal;
        }

        public Integer getCapacity() {
            return capacity;
        }

        public void setCapacity(Integer capacity) {
            this.capacity = capacity;
        }
    }


    /**
     * Collection of RateLimit.
     * Frameworks without rate limits defined here are not throttled unless
     * 'aggregate_default_qps' is specified.
     */
    public static class RateLimits {
        // Items should have unique principals.
        List<RateLimit> limits;

        // All the frameworks not specified in 'limits' get this default rate.
        // This rate is an aggregate rate for all of them, i.e., their combined
        // traffic is throttled together at this rate.
        Double aggregate_default_qps;

        // All the frameworks not specified in 'limits' get this default capacity.
        // This is an aggregate value similar to 'aggregate_default_qps'.
        Integer aggregate_default_capacity;
    }


    /**
     * Describe an image used by tasks or executors. Note that it's only
     * for tasks or executors launched by MesosContainerizer currently.
     */
    public static class Image {
        public enum Type {
            APPC,
            DOCKER
        }

        // Protobuf for specifying an Appc container image. See:
        // https://github.com/appc/spec/blob/master/spec/aci.md
        public static class Appc {
            // The name of the image.
            String name;

            // An image ID is a String of the format "hash-value", where
            // "hash" is the hash algorithm used and "value" is the hex
            // encoded String of the digest. Currently the only permitted
            // hash algorithm is sha512.
            String id;

            //  labels. Suggested labels: "version", "os", and "arch".
            Labels labels;
        }

        public static class Docker {
            // The name of the image. Expected format:
            //   [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG|@TYPE:DIGEST]
            //
            // See: https://docs.docker.com/reference/commandline/pull/
            String name;

            // Credential to authenticate with docker registry.
            // NOTE: This is not encrypted, therefore framework and operators
            // should enable SSL when passing this information.
            //
            // This field has never been used in Mesos before and is
            // deprecated since Mesos 1.3. Please use `config` below
            // (see MESOS-7088 for details).
            Credential credential; // Since 1.3.

            // Docker config containing credentails to authenticate with
            // docker registry. The secret is expected to be a docker
            // config file in JSON format with UTF-8 character encoding.
            Secret config;
        }

        Type type;

        // Only one of the following image messages should be set to match
        // the type.
        Appc appc;
        Docker docker;

        // With this flag set to false, the mesos containerizer will pull
        // the docker/appc image from the registry even if the image is
        // already downloaded on the agent.
        Boolean cached  = true;
    }


    /**
     * Describes how the mount will be propagated for a volume. See the
     * following doc for more details about mount propagation:
     * https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
     */
    public static class MountPropagation {
        public enum Mode {
            UNKNOWN,

            // The volume in a container will receive new mounts from the host
            // or other containers, but filesystems mounted inside the
            // container won't be propagated to the host or other containers.
            // This is currently the default behavior for all volumes.
            HOST_TO_CONTAINER,

            // The volume in a container will receive new mounts from the host
            // or other containers, and its own mounts will be propagated from
            // the container to the host or other containers.
            BIDIRECTIONAL
        }

        Mode mode;
    }


    /**
     * Describes a volume mapping either from host to container or vice
     * versa. Both paths can either refer to a directory or a file.
     */
    public static class Volume {
        public enum Mode {
            RW, // read-write.
            RO // read-only.
        }

        // TODO(gyliu513): Make this as `` after deprecation cycle of 1.0.
        Mode mode;

        // Path pointing to a directory or file in the container. If the
        // path is a relative path, it is relative to the container work
        // directory. If the path is an absolute path, that path must
        // already exist.
        String container_path;

        // The following specifies the source of this volume. At most one of
        // the following should be set.

        // Absolute path pointing to a directory or file on the host or a
        // path relative to the container work directory.
        String host_path;

        // The source of the volume is an Image which describes a root
        // filesystem which will be provisioned by Mesos.
        Image image;

        // Describes where a volume originates from.
        public static class Source {
            public enum Type {
                // This must be the first public enum value in this list, to
                // ensure that if 'type' is not set, the default value
                // is UNKNOWN. This enables public enum values to be added
                // in a backwards-compatible way. See: MESOS-4997.
                UNKNOWN,

                // TODO(gyliu513): Add IMAGE as volume source type.
                DOCKER_VOLUME,
                HOST_PATH,
                SANDBOX_PATH,
                SECRET
            }

            public static class DockerVolume {
                // Driver of the volume, it can be flocker, convoy, raxrey etc.
                String driver;

                // Name of the volume.
                String name;

                // Volume driver specific options.
                Parameters driver_options;

                public String getDriver() {
                    return driver;
                }

                public void setDriver(String driver) {
                    this.driver = driver;
                }

                public String getName() {
                    return name;
                }

                public void setName(String name) {
                    this.name = name;
                }

                public Parameters getDriver_options() {
                    return driver_options;
                }

                public void setDriver_options(Parameters driver_options) {
                    this.driver_options = driver_options;
                }
            }

            // Absolute path pointing to a directory or file on the host.
            public static class HostPath {
                String path;
                MountPropagation mount_propagation;

                public String getPath() {
                    return path;
                }

                public void setPath(String path) {
                    this.path = path;
                }

                public MountPropagation getMount_propagation() {
                    return mount_propagation;
                }

                public void setMount_propagation(MountPropagation mount_propagation) {
                    this.mount_propagation = mount_propagation;
                }
            }

            // Describe a path from a container's sandbox. The container can
            // be the current container (SELF), or its parent container
            // (PARENT). PARENT allows all child containers to share a volume
            // from their parent container's sandbox. It'll be an error if
            // the current container is a top level container.
            public static class SandboxPath {
                public enum Type {
                    UNKNOWN,
                    SELF,
                    PARENT
                }

                Type type;

                // A path relative to the corresponding container's sandbox.
                // Note that upwards traversal (i.e. ../../abc) is not allowed.
                String path;

                public Type getType() {
                    return type;
                }

                public void setType(Type type) {
                    this.type = type;
                }

                public String getPath() {
                    return path;
                }

                public void setPath(String path) {
                    this.path = path;
                }
            }

            // public enum fields should be , see: MESOS-4997.
            Type type;

            // The following specifies the source of this volume. At most one of
            // the following should be set.

            // The source of the volume created by docker volume driver.
            DockerVolume docker_volume;

            HostPath host_path;
            SandboxPath sandbox_path;

            // The volume/secret isolator uses the secret-fetcher module (third-party or
            // internal) downloads the secret and makes it available at container_path.
            Secret secret;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }

            public DockerVolume getDocker_volume() {
                return docker_volume;
            }

            public void setDocker_volume(DockerVolume docker_volume) {
                this.docker_volume = docker_volume;
            }

            public HostPath getHost_path() {
                return host_path;
            }

            public void setHost_path(HostPath host_path) {
                this.host_path = host_path;
            }

            public SandboxPath getSandbox_path() {
                return sandbox_path;
            }

            public void setSandbox_path(SandboxPath sandbox_path) {
                this.sandbox_path = sandbox_path;
            }

            public Secret getSecret() {
                return secret;
            }

            public void setSecret(Secret secret) {
                this.secret = secret;
            }
        }

        Source source;

        public Mode getMode() {
            return mode;
        }

        public void setMode(Mode mode) {
            this.mode = mode;
        }

        public String getContainer_path() {
            return container_path;
        }

        public void setContainer_path(String container_path) {
            this.container_path = container_path;
        }

        public String getHost_path() {
            return host_path;
        }

        public void setHost_path(String host_path) {
            this.host_path = host_path;
        }

        public Image getImage() {
            return image;
        }

        public void setImage(Image image) {
            this.image = image;
        }

        public Source getSource() {
            return source;
        }

        public void setSource(Source source) {
            this.source = source;
        }
    }


    /**
     * Describes a network request from a framework as well as network resolution
     * provided by Mesos.
     *
     * A framework may request the network isolator on the Agent to isolate the
     * container in a network namespace and create a virtual network interface.
     * The `NetworkInfo` public static class describes the properties of that virtual
     * interface, including the IP addresses and network isolation policy
     * (network group membership).
     *
     * The NetworkInfo public static class is not interpreted by the Master or Agent and is
     * intended to be used by Agent and Master modules implementing network
     * isolation. If the modules are missing, the public static class is simply ignored. In
     * future, the task launch will fail if there is no module providing the
     * network isolation capabilities (MESOS-3390).
     *
     * An executor, Agent, or an Agent module may append NetworkInfos inside
     * TaskStatus::container_status to provide information such as the container IP
     * address and isolation groups.
     */
    public static class NetworkInfo {
        public enum Protocol {
            IPv4,
            IPv6
        }

        // Specifies a request for an IP address, or reports the assigned container
        // IP address.
        //
        // Users can request an automatically assigned IP (for example, via an
        // IPAM service) or a specific IP by adding a NetworkInfo to the
        // ContainerInfo for a task.  On a request, specifying neither `protocol`
        // nor `ip_address` means that any available address may be assigned.
        public static class IPAddress {
            // Specify IP address requirement. Set protocol to the desired value to
            // request the network isolator on the Agent to assign an IP address to the
            // container being launched. If a specific IP address is specified in
            // ip_address, this field should not be set.
            Protocol protocol  = Protocol.IPv4;

            // Statically assigned IP provided by the Framework. This IP will be
            // assigned to the container by the network isolator module on the Agent.
            // This field should not be used with the protocol field above.
            //
            // If an explicit address is requested but is unavailable, the network
            // isolator should fail the task.
            String ip_address;

            public Protocol getProtocol() {
                return protocol;
            }

            public void setProtocol(Protocol protocol) {
                this.protocol = protocol;
            }

            public String getIp_address() {
                return ip_address;
            }

            public void setIp_address(String ip_address) {
                this.ip_address = ip_address;
            }
        }

        // When included in a ContainerInfo, each of these represent a
        // request for an IP address. Each request can specify an explicit address
        // or the IP protocol to use.
        //
        // When included in a TaskStatus message, these inform the framework
        // scheduler about the IP addresses that are bound to the container
        // interface. When there are no custom network isolator modules installed,
        // this field is filled in automatically with the Agent IP address.
        List<IPAddress> ip_addresses;

        // Name of the network which will be used by network isolator to determine
        // the network that the container joins. It's up to the network isolator
        // to decide how to interpret this field.
        String name;

        // A group is the name given to a set of logically-related interfaces that
        // are allowed to communicate among themselves. Network traffic is allowed
        // between two container interfaces that share at least one network group.
        // For example, one might want to create separate groups for isolating dev,
        // testing, qa and prod deployment environments.
        List<String> groups;

        // To tag certain metadata to be used by Isolator/IPAM, e.g., rack, etc.
        Labels labels;

        // Specifies a port mapping request for the task on this network.
        public static class PortMapping {
            Integer host_port;
            Integer container_port;
            // Protocol to expose as (ie: tcp, udp).
            String protocol;

            public Integer getHost_port() {
                return host_port;
            }

            public void setHost_port(Integer host_port) {
                this.host_port = host_port;
            }

            public Integer getContainer_port() {
                return container_port;
            }

            public void setContainer_port(Integer container_port) {
                this.container_port = container_port;
            }

            public String getProtocol() {
                return protocol;
            }

            public void setProtocol(String protocol) {
                this.protocol = protocol;
            }
        }

        List<PortMapping> port_mappings;

        public List<IPAddress> getIp_addresses() {
            return ip_addresses;
        }

        public void setIp_addresses(List<IPAddress> ip_addresses) {
            this.ip_addresses = ip_addresses;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public List<String> getGroups() {
            return groups;
        }

        public void setGroups(List<String> groups) {
            this.groups = groups;
        }

        public Labels getLabels() {
            return labels;
        }

        public void setLabels(Labels labels) {
            this.labels = labels;
        }

        public List<PortMapping> getPort_mappings() {
            return port_mappings;
        }

        public void setPort_mappings(List<PortMapping> port_mappings) {
            this.port_mappings = port_mappings;
        }
    };


    /**
     * Encapsulation of `Capabilities` supported by Linux.
     * Reference: http://linux.die.net/man/7/capabilities.
     */
    public static class CapabilityInfo {
        // We start the actual values at an offset(1000) because Protobuf 2
        // uses the first value as the default one. Separating the default
        // value from the real first value helps to disambiguate them. This
        // is especially valuable for backward compatibility.
        // See: MESOS-4997.
        public enum Capability {
            UNKNOWN,
            CHOWN,
            DAC_OVERRIDE,
            DAC_READ_SEARCH,
            FOWNER,
            FSETID,
            KILL,
            SETGID,
            SETUID,
            SETPCAP,
            LINUX_IMMUTABLE,
            NET_BIND_SERVICE,
            NET_BROADCAST,
            NET_ADMIN,
            NET_RAW,
            IPC_LOCK,
            IPC_OWNER,
            SYS_MODULE,
            SYS_RAWIO,
            SYS_CHROOT,
            SYS_PTRACE,
            SYS_PACCT,
            SYS_ADMIN,
            SYS_BOOT,
            SYS_NICE,
            SYS_RESOURCE,
            SYS_TIME,
            SYS_TTY_CONFIG,
            MKNOD,
            LEASE,
            AUDIT_WRITE,
            AUDIT_CONTROL,
            SETFCAP,
            MAC_OVERRIDE,
            MAC_ADMIN,
            SYSLOG,
            WAKE_ALARM,
            BLOCK_SUSPEND,
            AUDIT_READ
        }

        List<Capability> capabilities;

        public List<Capability> getCapabilities() {
            return capabilities;
        }

        public void setCapabilities(List<Capability> capabilities) {
            this.capabilities = capabilities;
        }
    }


    /**
     * Encapsulation for Linux specific configuration.
     * E.g, capabilities, limits etc.
     */
    public static class LinuxInfo {
        // Since 1.4.0, deprecated in favor of `effective_capabilities`.
        CapabilityInfo capability_info;

        // The set of capabilities that are allowed but not initially
        // granted to tasks.
        CapabilityInfo bounding_capabilities;

        // Represents the set of capabilities that the task will
        // be executed with.
        CapabilityInfo effective_capabilities;

        // If set as 'true', the container shares the pid namespace with
        // its parent. If the container is a top level container, it will
        // share the pid namespace with the agent. If the container is a
        // nested container, it will share the pid namespace with its
        // parent container. This field will be ignored if 'namespaces/pid'
        // isolator is not enabled.
        Boolean share_pid_namespace;

        public CapabilityInfo getCapability_info() {
            return capability_info;
        }

        public void setCapability_info(CapabilityInfo capability_info) {
            this.capability_info = capability_info;
        }

        public CapabilityInfo getBounding_capabilities() {
            return bounding_capabilities;
        }

        public void setBounding_capabilities(CapabilityInfo bounding_capabilities) {
            this.bounding_capabilities = bounding_capabilities;
        }

        public CapabilityInfo getEffective_capabilities() {
            return effective_capabilities;
        }

        public void setEffective_capabilities(CapabilityInfo effective_capabilities) {
            this.effective_capabilities = effective_capabilities;
        }

        public Boolean getShare_pid_namespace() {
            return share_pid_namespace;
        }

        public void setShare_pid_namespace(Boolean share_pid_namespace) {
            this.share_pid_namespace = share_pid_namespace;
        }
    }


    /**
     * Encapsulation for POSIX rlimits, see
     * http://pubs.opengroup.org/onlinepubs/009695399/functions/getrlimit.html.
     * Note that some types might only be defined for Linux.
     * We use a custom prefix to avoid conflict with existing system macros
     * (e.g., `RLIMIT_CPU` or `NOFILE`).
     */
    public static class RLimitInfo {
        public static class RLimit {
            public enum Type {
                UNKNOWN,
                RLMT_AS,
                RLMT_CORE,
                RLMT_CPU,
                RLMT_DATA,
                RLMT_FSIZE,
                RLMT_LOCKS,
                RLMT_MEMLOCK,
                RLMT_MSGQUEUE,
                RLMT_NICE,
                RLMT_NOFILE0,
                RLMT_NPROC1,
                RLMT_RSS2,
                RLMT_RTPRIO3,
                RLMT_RTTIME4,
                RLMT_SIGPENDING5,
                RLMT_STACK6
            }
            Type type;

            // Either both are set or both are not set.
            // If both are not set, it represents unlimited.
            // If both are set, we require `soft` <= `hard`.
            Integer hard;
            Integer soft;

            public Type getType() {
                return type;
            }

            public void setType(Type type) {
                this.type = type;
            }

            public Integer getHard() {
                return hard;
            }

            public void setHard(Integer hard) {
                this.hard = hard;
            }

            public Integer getSoft() {
                return soft;
            }

            public void setSoft(Integer soft) {
                this.soft = soft;
            }
        }

        List<RLimit> rlimits;

        public List<RLimit> getRlimits() {
            return rlimits;
        }

        public void setRlimits(List<RLimit> rlimits) {
            this.rlimits = rlimits;
        }
    }


    /**
     * Describes the information about (pseudo) TTY that can
     * be attached to a process running in a container.
     */
    public static class TTYInfo {
        public static class WindowSize {
            Integer rows;
            Integer columns;

            public Integer getRows() {
                return rows;
            }

            public void setRows(Integer rows) {
                this.rows = rows;
            }

            public Integer getColumns() {
                return columns;
            }

            public void setColumns(Integer columns) {
                this.columns = columns;
            }
        }

        WindowSize window_size;

        public WindowSize getWindow_size() {
            return window_size;
        }

        public void setWindow_size(WindowSize window_size) {
            this.window_size = window_size;
        }
    }


    /**
     * Describes a container configuration and allows extensible
     * configurations for different container implementations.
     *
     * NOTE: `ContainerInfo` may be specified, e.g., by a task, even if no
     * container image is provided. In this case neither `MesosInfo` nor
     * `DockerInfo` is set, the `type` must be `MESOS`. This is to
     * address a case when a task without an image, e.g., a shell script
     * with URIs, wants to use features originally designed for containers,
     * for example custom network isolation via `NetworkInfo`.
     */
    public static class ContainerInfo {
        // All container implementation types.
        public enum Type {
            DOCKER,
            MESOS
        }

        public static class DockerInfo {
            // The docker image that is going to be passed to the registry.
            String image;

            // Network options.
            public enum Network {
                HOST,
                BRIDGE,
                NONE,
                USER
            }

            Network network  = Network.HOST;

            public static class PortMapping {
                Integer host_port;
                Integer container_port;
                // Protocol to expose as (ie: tcp, udp).
                String protocol;

                public Integer getHost_port() {
                    return host_port;
                }

                public void setHost_port(Integer host_port) {
                    this.host_port = host_port;
                }

                public Integer getContainer_port() {
                    return container_port;
                }

                public void setContainer_port(Integer container_port) {
                    this.container_port = container_port;
                }

                public String getProtocol() {
                    return protocol;
                }

                public void setProtocol(String protocol) {
                    this.protocol = protocol;
                }
            }

            List<PortMapping> port_mappings;

            Boolean privileged  = false;

            // Allowing arbitrary parameters to be passed to docker CLI.
            // Note that anything passed to this field is not guaranteed
            // to be supported moving forward, as we might move away from
            // the docker CLI.
            List<Parameter> parameters;

            // With this flag set to true, the docker containerizer will
            // pull the docker image from the registry even if the image
            // is already downloaded on the agent.
            Boolean force_pull_image;

            // The name of volume driver plugin.
            String volume_driver; // Since 1.0

            public String getImage() {
                return image;
            }

            public void setImage(String image) {
                this.image = image;
            }

            public Network getNetwork() {
                return network;
            }

            public void setNetwork(Network network) {
                this.network = network;
            }

            public List<PortMapping> getPort_mappings() {
                return port_mappings;
            }

            public void setPort_mappings(List<PortMapping> port_mappings) {
                this.port_mappings = port_mappings;
            }

            public Boolean getPrivileged() {
                return privileged;
            }

            public void setPrivileged(Boolean privileged) {
                this.privileged = privileged;
            }

            public List<Parameter> getParameters() {
                return parameters;
            }

            public void setParameters(List<Parameter> parameters) {
                this.parameters = parameters;
            }

            public Boolean getForce_pull_image() {
                return force_pull_image;
            }

            public void setForce_pull_image(Boolean force_pull_image) {
                this.force_pull_image = force_pull_image;
            }

            public String getVolume_driver() {
                return volume_driver;
            }

            public void setVolume_driver(String volume_driver) {
                this.volume_driver = volume_driver;
            }
        }

        public static class MesosInfo {
            Image image;

            public Image getImage() {
                return image;
            }

            public void setImage(Image image) {
                this.image = image;
            }
        }

        Type type;
        List<Volume> volumes;
        String hostname;

        // Only one of the following *Info messages should be set to match
        // the type.
        DockerInfo docker;
        MesosInfo mesos;

        // A list of network requests. A framework can request multiple IP addresses
        // for the container.
        List<NetworkInfo> network_infos;

        // Linux specific information for the container.
        LinuxInfo linux_info;

        // (POSIX only) rlimits of the container.
        RLimitInfo rlimit_info;

        // If specified a tty will be attached to the container entrypoint.
        TTYInfo tty_info;

        public Type getType() {
            return type;
        }

        public void setType(Type type) {
            this.type = type;
        }

        public List<Volume> getVolumes() {
            return volumes;
        }

        public void setVolumes(List<Volume> volumes) {
            this.volumes = volumes;
        }

        public String getHostname() {
            return hostname;
        }

        public void setHostname(String hostname) {
            this.hostname = hostname;
        }

        public DockerInfo getDocker() {
            return docker;
        }

        public void setDocker(DockerInfo docker) {
            this.docker = docker;
        }

        public MesosInfo getMesos() {
            return mesos;
        }

        public void setMesos(MesosInfo mesos) {
            this.mesos = mesos;
        }

        public List<NetworkInfo> getNetwork_infos() {
            return network_infos;
        }

        public void setNetwork_infos(List<NetworkInfo> network_infos) {
            this.network_infos = network_infos;
        }

        public LinuxInfo getLinux_info() {
            return linux_info;
        }

        public void setLinux_info(LinuxInfo linux_info) {
            this.linux_info = linux_info;
        }

        public RLimitInfo getRlimit_info() {
            return rlimit_info;
        }

        public void setRlimit_info(RLimitInfo rlimit_info) {
            this.rlimit_info = rlimit_info;
        }

        public TTYInfo getTty_info() {
            return tty_info;
        }

        public void setTty_info(TTYInfo tty_info) {
            this.tty_info = tty_info;
        }
    }


    /**
     * Container related information that is resolved during container
     * setup. The information is sent back to the framework as part of the
     * TaskStatus message.
     */
    public static class ContainerStatus {
        ContainerID container_id;

        // This field can be reliably used to identify the container IP address.
        List<NetworkInfo> network_infos;

        // Information about Linux control group (cgroup).
        CgroupInfo cgroup_info;

        // Information about Executor PID.
        Integer executor_pid;

        public ContainerID getContainer_id() {
            return container_id;
        }

        public void setContainer_id(ContainerID container_id) {
            this.container_id = container_id;
        }

        public List<NetworkInfo> getNetwork_infos() {
            return network_infos;
        }

        public void setNetwork_infos(List<NetworkInfo> network_infos) {
            this.network_infos = network_infos;
        }

        public CgroupInfo getCgroup_info() {
            return cgroup_info;
        }

        public void setCgroup_info(CgroupInfo cgroup_info) {
            this.cgroup_info = cgroup_info;
        }

        public Integer getExecutor_pid() {
            return executor_pid;
        }

        public void setExecutor_pid(Integer executor_pid) {
            this.executor_pid = executor_pid;
        }
    }


    /**
     * Linux control group (cgroup) information.
     */
    public static class CgroupInfo {
        // Configuration of a blkio cgroup subsystem.
        public static class Blkio {
            public enum Operation {
                UNKNOWN,
                TOTAL,
                READ,
                WRITE,
                SYNC,
                ASYNC
            }

            // Describes a stat value without the device descriptor part.
            public static class Value {
                Operation op; // Required.
                Integer value; // Required.
            }

            public static class CFQ {
                public static class Statistics {
                    // Stats are grouped by block devices. If `device` is not
                    // set, it represents `Total`.
                    Device.Number device;
                    // blkio.sectors
                    Integer sectors;
                    // blkio.time
                    Integer time;
                    // blkio.io_serviced
                    List<Value> io_serviced;
                    // blkio.io_service_byte[]
                    List<Value> io_service_byte[];
                    // blkio.io_service_time
                    List<Value> io_service_time;
                    // blkio.io_wait_time
                    List<Value> io_wait_time;
                    // blkio.io_merged
                    List<Value> io_merged;
                    // blkio.io_queued
                    List<Value> io_queued;
                }

                // TODO(jasonlai): Add fields for blkio weight and weight
                // device.
            }

            public static class Throttling {
                public static class Statistics {
                    // Stats are grouped by block devices. If `device` is not
                    // set, it represents `Total`.
                    Device.Number device;
                    // blkio.throttle.io_serviced
                    List<Value> io_serviced;
                    // blkio.throttle.io_service_byte[]
                    List<Value> io_service_bytes;
                }

                // TODO(jasonlai): Add fields for blkio.throttle.*_device.
            }

            public static class Statistics {
                List<CFQ.Statistics> cfq;
                List<CFQ.Statistics> cfq_recursive;
                List<Throttling.Statistics> throttling;
            }
        }

        // Configuration of a net_cls cgroup subsystem.
        public static class NetCls {
            // The 32-bit classid consists of two parts, a 16 bit major handle
            // and a 16-bit minor handle. The major and minor handle are
            // represented using the format 0xAAAABBBB, where 0xAAAA is the
            // 16-bit major handle and 0xBBBB is the 16-bit minor handle.
            Integer classid;
        }

        NetCls net_cls;
    }


    /**
     * Collection of labels. Labels should not contain duplicate key-value
     * pairs.
     */
    public static class Labels {
        List<Label> labels;
    }


    /**
     * Key, value pair used to store free form user-data.
     */
    public static class Label {
        String key;
        String value;
    }


    /**
     * Named port used for service discovery.
     */
    public static class Port {
        // Port number on which the framework exposes a service.
        Integer number;

        // Name of the service hosted on this port.
        String name;

        // Layer 4-7 protocol on which the framework exposes its services.
        String protocol;

        // This field restricts discovery within a framework (FRAMEWORK),
        // within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
        // The visibility setting for a Port overrides the general visibility setting
        // in the DiscoveryInfo.
        DiscoveryInfo.Visibility visibility;

        // This can be used to decorate the public static class with metadata to be
        // interpreted by external applications such as firewalls.
        Labels labels;
    }


    /**
     * Collection of ports.
     */
    public static class Ports {
        List<Port> ports;
    }


    /**
     * Service discovery information.
     * The visibility field restricts discovery within a framework (FRAMEWORK),
     * within a Mesos cluster (CLUSTER), or places no restrictions (EXTERNAL).
     * Each port in the ports field also has an  visibility field.
     * If visibility is specified for a port, it overrides the default service-wide
     * DiscoveryInfo.visibility for that port.
     * The environment, location, and version fields provide first class support for
     * common attributes used to differentiate between similar services. The
     * environment may receive values such as PROD/QA/DEV, the location field may
     * receive values like EAST-US/WEST-US/EUROPE/AMEA, and the version field may
     * receive values like v2.0/v0.9. The exact use of these fields is up to each
     * service discovery system.
     */
    public static class DiscoveryInfo {
        public enum Visibility {
            FRAMEWORK,
            CLUSTER,
            EXTERNAL
        }

        Visibility visibility;
        String name;
        String environment;
        String location;
        String version;
        Ports ports;
        Labels labels;
    }


    /**
     * Named WeightInfo to indicate resource allocation
     * priority between the different roles.
     */
    public static class WeightInfo {
        Double weight;

        // Related role name.
        String role;
    }


    /**
     * Version information of a component.
     */
    public static class VersionInfo {
        String version;
        String build_date;
        Double build_time;
        String build_user;
        String git_sha;
        String git_branch;
        String git_tag;
    }


    /**
     * Flag consists of a name and ly its value.
     */
    public static class Flag {
        String name;
        String value;
    }


    /**
     * Describes a Role. Roles can be used to specify that certain resources are
     * reserved for the use of one or more frameworks.
     */
    public static class Role {
        String name;
        Double weight;
        List<FrameworkID> frameworks;
        List<Resource> resources;
    }


    /**
     * Metric consists of a name and ly its value.
     */
    public static class Metric {
        String name;
        Double value;
    }


    /**
     * Describes a File.
     */
    public static class FileInfo {
        // Absolute path to the file.
        String path;

        // Number of hard links.
        Integer nlink;

        // Total size in byte[].
        Integer size;

        // Last modification time.
        TimeInfo mtime;

        // Represents a file's mode and permission bits. The bits have the same
        // definition on all systems and is portable.
        Integer mode;

        // User ID of owner.
        String uid;

        // Group ID of owner.
        String gid;
    }


    /**
     * Describes information abount a device.
     */
    public static class Device {
        public static class Number {
            Integer major_number;
            Integer minor_number;
        }

        String path;
        Number number;
    }


    /**
     * Describes a device whitelist entry that expose from host to container.
     */
    public static class DeviceAccess {
        public static class Access {
            Boolean read;
            Boolean write;
            Boolean mknod;
        }
        Device device;
        Access access;
    }


    public static class DeviceWhitelist {
        List<DeviceAccess> allowed_devices;
    }
}
